#+STYLE: <link rel="stylesheet" type="text/css" href="style.css">
#+STARTUP: indent
#+TITLE: pm: Project management

This is how I manage the projects I work on.

* Tasks

I'm putting some tasks here as an example.

** Do a big thing
Do something that involves lots of smaller tasks getting done.
*** DONE Smaller thing 1
:LOGBOOK:
- State "DONE"       from "DOING"      [2021-07-30 Fri 09:53] \\
  Smaller thing 1 done! Results sent to *someone*.
:END:
*** DONE Smaller thing 2
:LOGBOOK:
- State "DONE"       from "DOING"      [2021-08-06 Fri 09:55] \\
  Smaller thing 2 finished, and sent off to customer.
:END:
** On the horizon
*** TODO Do the laundry
This will never get done....
*** DONE Eat breakfast
Done, but hardly an accomplishment




* Code

** Exploration

  (let ((config (list :log-into-drawer "LOGBOOK" :clock-into-drawer t)))
      (->> (org-ml-parse-subtrees 'all)
           (org-ml-match '(:any * (:todo-keyword "DONE")))
           (--map (org-ml-headline-get-logbook-items config it))))
#+end_src


Let's pull apart this functionality. First: finding finished tasks.

#+begin_src emacs-lisp :noweb-ref finished-tasks
  (defun pg-pm--finished-tasks (node)
    "Return nodes for all tasks under NODE with the keyword DONE.

  As a practical matter, NODE can be a list of subtrees (i.e., the
  return value of `org-ml-parse-subtrees')"
    (org-ml-match '(:any * (:todo-keyword "DONE")) node))
#+end_src

Next, pulling off logbook items. This may get consolidated into the logbook entry processing below....

#+begin_src emacs-lisp :noweb-ref headline-logbook-items
  (defcustom pg-pm-project-file-logging-config
    '(:log-into-drawer "LOGBOOK" :clock-into-drawer t)
    "Logging format for drawers in project files.")


  (defun pg-pm--headline-logbook-items (headline)
    "Use `org-ml-headline-get-logbook-items' to pull logbook items
  off HEADLINE."
    (org-ml-headline-get-logbook-items
     pg-pm-project-file-logging-config
     headline))
#+end_src


Let's test this out

#+begin_src emacs-lisp :noweb yes :results code :exports code
  <<finished-tasks>>
  <<headline-logbook-items>>

  (->> (org-ml-parse-subtrees 'all)
       (pg-pm--finished-tasks)
       (-map #'pg-pm--headline-logbook-items))
#+end_src




*** Tracking state transitions

The old solution for identifying when a headline was resolved as =DONE= and what notes were provided:

#+begin_src emacs-lisp :noweb yes :results code :exports code
  <<finished-tasks>>
  <<headline-logbook-items>>

  (defconst pg-pm--rx-logbook-resolved-old
    (rx "State"
        (+ whitespace)
        "\"DONE\""
        (+ whitespace)
        "from"
        (+ whitespace)
        "\"" (+ (not "\"")) "\"" )
    "Regex matching the transition to the DONE state, per the
    default state format string in
    `org-log-note-headings'. Capturing accomplishments will break
    if that entry in `org-log-note-headings' is changed. (As will large chunks of
    org-agenda.)")



  (defun pg-pm--logbook-resolution? (logbook-item)
    "If LOGBOOK-ITEM is an entry that signals the resolution of a
    to-do item, return the timestamp of the resolution and any
    additional information provided about it. If this set of
    logbook items does not contain a resolution, return
    nil. LOGBOOK-ITEMS should be a single item from a logbook.

  A resolution is defined as a state transition to \"DONE\". This
  function relies on the format of te state change entry being
  consistent with the default value of the state entry in
  `org-log-note-headings'. If that variable is changed for some
  reason, `pg-pm--rx-logbook-resolved' can be changed to properly
  identify resolutions."
    (let* ((objects (org-ml-item-get-paragraph logbook-item))
           (res? (->> (car objects)
                      (org-ml-to-trimmed-string)
                      (s-matches? pg-pm--rx-logbook-resolved-old))))
      (when res?
        (let ((ts   (--> (cadr objects)
                         (when (org-ml-is-type 'timestamp it) it)))
              (addl (--> (caddr objects)
                         (when (org-ml-is-type 'line-break it)
                           (s-join "" (-map #'org-ml-to-trimmed-string (cdddr objects)))))))
          (list ts addl)))))

  ;; Used like this

  (->> (org-ml-parse-subtrees 'all)
       (pg-pm--finished-tasks)
       (-map #'pg-pm--headline-logbook-items)
       (first)
       (first))
#+end_src

#+RESULTS:


This sucks, more or less.

Just plucking log entries recording a transition to =DONE= in headlines is not very robust. What if the item was closed and later reopened and re-closed, possibly without making a logbook entry? The entry may or may not refer to the most recent closure.

So instead, we need to parse all the state transition logbook entries in order, and ensure that we're only looking at the most recent one for extra information.

We also want to keep the resolution tied to the headline. Solving the problem for a single headline and generalizing from that makes more sense than the solution above, which creates a list of resolutions and leaves the problem of tying them back to headlines until last (and never fixed, either).

Its easy enough to generalize the regex for any state transition.

**** Parsing state transition entries

#+begin_src emacs-lisp :noweb-ref strans-regex
  (defconst pg-pm--rx-logbook-resolved
    (rx "State"
        (+ whitespace)
        "\"" (group (+ (not "\""))) "\""
        (+ whitespace)
        "from"
        (+ whitespace)
        "\"" (group (+ (not "\""))) "\"")
    "Regex matching log entries of to-do state transitions, per the
    default state format string in
    `org-log-note-headings'. Capturing accomplishments will break
    if that entry in `org-log-note-headings' is changed. (As will
    large chunks of org-agenda.)")
#+end_src

A function using it to identify and extract the data we need from a single log entry is similarly straightforward. (One thing the function above does right is solving the problem for a specific logbook entry. We'll keep that, but change how it's used later.)



#+begin_src emacs-lisp :noweb-ref parse-strans-log-entry
  (defun pg-pm--parse-strans-log-entry (lb-item)
    "If LB-ITEM is a logbook entry that looks like it was generated
  when a to-do item's status changed, parse it and return a list of
  the state it was changed to (as a symbol), the state it was
  changed from (as a symbol), the timestamp, and an org paragraph
  element representing any additional notes provided by the
  user. Otherwise, return nil."
    ;; Start by getting the paragraph portion of the logbook item
    (-when-let* [((s ts . the-rest)  (org-ml-item-get-paragraph lb-item))
                 ;; parse out the to and from states
                 ((_ to from) (->> (org-ml-to-trimmed-string s)
                                   (s-match pg-pm--rx-logbook-resolved)))
                 ;; if notes exist, create as new paragraph
                 (notes (if (org-ml-is-type 'line-break (first (pg-util-spy the-rest)))
                            ;; trick to inline (cdr the-rest) as args
                            (let ((para-objs (-map (lambda (x) `(quote ,x)) (cdr the-rest))))
                              (eval `(org-ml-build-paragraph ,@(cdr para-objs))))
                          ;; no additional notes == empty paragraph
                          (org-ml-build-paragraph)))]
      (list (intern to) (intern from) ts notes)))
#+end_src

#+RESULTS:
: pg-pm--parse-strans-log-entry


That's a little dense. Let's test it out.

#+begin_src emacs-lisp :noweb yes :results code :exports code
  <<finished-tasks>>
  <<headline-logbook-items>>
  <<strans-regex>>
  <<parse-strans-log-entry>>

  (->> (org-ml-parse-subtrees 'all)
       (pg-pm--finished-tasks)
       (first)
       (pg-pm--headline-logbook-items)
       (first)
       (pg-pm--parse-strans-log-entry))
#+end_src

#+RESULTS:

Kind of ugly, but it will get cleaned up shortly.

***** Fun with timestamps

Let's do a little spike and figure out what's possible with time stamps.

#+begin_src emacs-lisp :noweb yes :results code :exports code
  <<finished-tasks>>
  <<headline-logbook-items>>
  <<strans-regex>>
  <<parse-strans-log-entry>>

  (->> (org-ml-parse-subtrees 'all)
       (pg-pm--finished-tasks)
       (first)
       (pg-pm--headline-logbook-items)
       (first)
       (pg-pm--parse-strans-log-entry)
       ;; Pull out the timestamp
       (nth 2)
       (ts-parse-org-element))
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
#s(ts 9 53 0 30 7 2021 nil nil nil nil nil nil nil nil nil nil nil)
#+end_src


So that's how we bridge the gap between =org-ml= and =ts=.



*** Building an accomplishment record

What we just did to test =pg-pm--parse-strans-log-entry= is more or less what we need to do for each headline we're looking at. So let's put it into a function.

But first, what is an accomplishment? A finished task is an accomplishment if and only if:

- It's completed (i.e., status is =DONE=)
- We have a record of its completion (i.e., the last state transition entry matches the state of the finished item)

We also need some description of what was accomplished. When it exists, the notes associated with the state transition entry serve the purpose. If notes do not exist, we will currently assume the actual text of the headline will suffice.

#+begin_src emacs-lisp :noweb-ref build-accomplishment
  (defun pg-pm--accomplishment? (headline strans-entries)
    "Returns a true value if the entries in STRANS-ENTRIES
    constitute an actual accomplishment, otherwise nil.

  STRANS-ENTRIES should be a list of state transition logbook
  entries, as processed by `pg-pm--parse-strans-log-entry'."
    ;; To be an accomplishment, there must be a logbook entry
    ;; corresponding to the current to-do state of the headline (so the
    ;; info in the first logbook entry and the headline to-do state must
    ;; match), and the to-do state of the headline must indicate that
    ;; the task is finished (which currently just means it's in state
    ;; DONE).
    ;;
    ;; If more than one to-do state indicated that a task was finished,
    ;; we'd also have to check that the state on the entry matched the
    ;; one on the headline, but with one finishing state, we get that
    ;; for free, so to speak.
    (and (equal "DONE" (org-ml-get-property :todo-keyword headline))
         (equal 'DONE (first (first strans-entries)))))


  (defun pg-pm--build-accomplishment (headline)
    "Return an accomplishment record for HEADLINE. The
  accomplishment record contains the headline, the transition log
  entry corresponding to the finishing of the accomplishment, and
  all the elements of the transition log entry, as returned by
  `pg-pm--parse-strans-log-entry'.

  If the headline is not, in fact, an accomplishment, this function
  returns nil."
    (let ((logbook-entries (->> headline
                                (pg-pm--headline-logbook-items)
                                (-map #'pg-pm--parse-strans-log-entry))))
      (when (pg-pm--accomplishment? headline logbook-entries)
        (list headline (first logbook-entries) logbook-entries))))
#+end_src

Used thusly:

#+begin_src emacs-lisp :noweb yes :results code :exports code
  <<finished-tasks>>
  <<headline-logbook-items>>
  <<strans-regex>>
  <<parse-strans-log-entry>>
  <<build-accomplishment>>

  (->> (org-ml-parse-subtrees 'all)
       (pg-pm--finished-tasks)
       (-keep #'pg-pm--build-accomplishment)
       (first))
#+end_src



As you can see, =pg-pm--build-accomplishment= is both a constructor and a predicate, so we can throw a list of maybe-accomplishments at it and use =-keep= to filter out the non-accomplishments.

*** Org-mode representation of accomplishments

The accomplishment record is convenient for processing, but we'll eventually want to represent accomplishments in Org. Building that now also gives us a "free" string representation.

#+begin_src emacs-lisp :noweb-ref accomplishment-to-org


  (defun pg-pm--accomplishment-to-org (accomplishment)
    "Convert an ACCOMPLISHMENT, an accomplishment record, to an
    org-element representation. If ACCOMPLISHMENT is nil, return
    nil."

    (-let* (((headline (_ _ ts notes)) accomplishment))
      (org-ml-build-headline
       :title (org-ml-get-property :title headline)
       (org-ml-build-section notes))))
#+end_src

#+RESULTS:
: pg-pm--accomplishment-to-org

Used thusly:

#+begin_src emacs-lisp :noweb yes :results code :exports code
  <<finished-tasks>>
  <<headline-logbook-items>>
  <<strans-regex>>
  <<parse-strans-log-entry>>
  <<build-accomplishment>>
  <<accomplishment-to-org>>


  (->> (org-ml-parse-subtrees 'all)
       (pg-pm--finished-tasks)
       (-keep #'pg-pm--build-accomplishment)
       (first)
       (pg-pm--accomplishment-to-org))
#+end_src

#+RESULTS:


*** Building an accomplishment record

What we just did to test =pg-pm--parse-strans-log-entry= is more or less what we need to do for each headline we're looking at. So let's put it into a function.

But first, what is an accomplishment? A finished task is an accomplishment if and only if:

- It's completed (i.e., status is =DONE=)
- We have a record of its completion (i.e., the last state transition entry matches the state of the finished item)

We also need some description of what was accomplished. When it exists, the notes associated with the state transition entry serve the purpose. If notes do not exist, we will currently assume the actual text of the headline will suffice.

#+begin_src emacs-lisp :noweb-ref build-accomplishment
  (defun pg-pm--accomplishment? (headline strans-entries)
    "Returns a true value if the entries in STRANS-ENTRIES
    constitute an actual accomplishment, otherwise nil.

  STRANS-ENTRIES should be a list of state transition logbook
  entries, as processed by `pg-pm--parse-strans-log-entry'."
    ;; To be an accomplishment, there must be a logbook entry
    ;; corresponding to the current to-do state of the headline (so the
    ;; info in the first logbook entry and the headline to-do state must
    ;; match), and the to-do state of the headline must indicate that
    ;; the task is finished (which currently just means it's in state
    ;; DONE).
    ;;
    ;; If more than one to-do state indicated that a task was finished,
    ;; we'd also have to check that the state on the entry matched the
    ;; one on the headline, but with one finishing state, we get that
    ;; for free, so to speak.
    (and (equal "DONE" (org-ml-get-property :todo-keyword headline))
         (equal 'DONE (first (first strans-entries)))))


  (defun pg-pm--build-accomplishment (headline)
    "Return an accomplishment record for HEADLINE. The
  accomplishment record contains the headline, the transition log
  entry corresponding to the finishing of the accomplishment, and
  all the elements of the transition log entry, as returned by
  `pg-pm--parse-strans-log-entry'.

  If the headline is not, in fact, an accomplishment, this function
  returns nil."
    (let ((logbook-entries (->> headline
                                (pg-pm--headline-logbook-items)
                                (-map #'pg-pm--parse-strans-log-entry))))
      (when (pg-pm--accomplishment? headline logbook-entries)
        (list headline (first logbook-entries) logbook-entries))))
#+end_src

Used thusly:

#+begin_src emacs-lisp :noweb yes :results code :exports code
  <<finished-tasks>>
  <<headline-logbook-items>>
  <<strans-regex>>
  <<parse-strans-log-entry>>
  <<build-accomplishment>>

  (->> (org-ml-parse-subtrees 'all)
       (pg-pm--finished-tasks)
       (-keep #'pg-pm--build-accomplishment)
       (first))
#+end_src



As you can see, =pg-pm--build-accomplishment= is both a constructor and a predicate, so we can throw a list of maybe-accomplishments at it and use =-keep= to filter out the non-accomplishments.

*** Org-mode representation of accomplishments

The accomplishment record is convenient for processing, but we'll eventually want to represent accomplishments in Org. Building that now also gives us a "free" string representation.

#+begin_src emacs-lisp :noweb-ref accomplishment-to-org
  (defun --org-ml-orphan (node)
    (org-ml-set-property :parent nil (pg-util-spy node)))

  (defun pg-pm--accomplishment-to-org (accomplishment)
    "Convert an ACCOMPLISHMENT, an accomplishment record, to an
    org-element representation. If ACCOMPLISHMENT is nil, return
    nil."

    (-let* (((headline (_ _ ts notes)) accomplishment)
            (h2 (org-ml-build-headline
                 :title (org-ml-get-property :title headline)
                 (org-ml-build-section notes))))
      nil))
#+end_src

#+RESULTS:
: pg-pm--accomplishment-to-org

Used thusly:

#+begin_src emacs-lisp :noweb yes :results code :exports code
  <<finished-tasks>>
  <<headline-logbook-items>>
  <<strans-regex>>
  <<parse-strans-log-entry>>
  <<build-accomplishment>>
  <<accomplishment-to-org>>


  (->> (org-ml-parse-subtrees 'all)
       (pg-pm--finished-tasks)
       (-keep #'pg-pm--build-accomplishment)
       (first)
       (pg-pm--accomplishment-to-org))
#+end_src

#+RESULTS:
