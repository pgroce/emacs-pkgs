#+STYLE: <link rel="stylesheet" type="text/css" href="style.css">
#+startup: indent
#+TITLE: pg-org.org: Customizations to org-mode

* Code

This library contains anything I may find specifically useful when working with Org Mode files, which I use constantly both in my regular workflow and as a literate programming tool.

** Package Header

#+name: src/header
#+BEGIN_SRC emacs-lisp
  ;;; pg-org.el --- Customizations to org-mode

  ;; Copyright (C) 2021 Phil Groce

  ;; Author: Phil Groce <pgroce@gmail.com>
  ;; Version: 0.2.2
  ;; Package-Requires: ((emacs "26.1") (org-ml "5.7") (dash "2.19") (s "1.12") (ts "0.3") (pg-ert "0.1"))
  ;; Keywords: productivity
#+END_SRC


** Requires

#+name: src/requires
#+begin_src emacs-lisp
  (require 'org-ml)
  (require 'dash)
  (require 's)
  (require 'ts)
#+end_src

** Working on Source Blocks

Being able to easily operate on blocks comes up during testing, and also in workflows where the Org file is being treated like an executable notebook. (See also: [[https://jupyter.org/][Jupyter Notebook]])

It should be easy to generalize this to all Org blocks, or even all named elements. I'm not inclined to do that right now, but the names of all the org elements types are in =org-element-all-elements= in =org-element.el=. (Not all of those can be named, however.)

#+name: src/pg-with-src
#+begin_src emacs-lisp :results silent
  (defmacro pg-org-with-src (block-name &rest body)
    "Put the text in the source block BLOCK-NAME in a temp buffer,
  then execute BODY in that buffer."
    (declare (indent 1))
    (let ((-src (make-symbol "-src")))
      `(cl-flet ((-assert (msg arg) (if (eq nil arg) (error msg) arg)))
         (let ((,-src

                (->> (org-ml-parse-this-buffer)
                     (org-ml-match
                      '(:any * (:and
                                src-block
                                (:name ,(symbol-name block-name)))))
                     (-assert (format "No src block %s" ,(symbol-name block-name)))
                     (car)
                     (org-ml-get-property :value))))
           ;;  Put the source block in a separate buffer and run the code in body
           (with-temp-buffer
             (insert ,-src)
             ,@body)))))


  (defmacro pg-org-with-src-doc (block-name &rest body)
    "Parse the text in the org-mode source block BLOCK-NAME into an
    org-element tree and run BODY. Code in BODY can refer to the
    org-element tree via the symbol `doc'."
    (declare (indent 1))
    `(lexical-let ((doc (pg-org-with-src ,block-name
                          (org-unescape-code-in-region (point-min) (point-max))
                          (org-do-remove-indentation)
                          (org-mode)
                          (org-ml-parse-this-buffer))))
       ,@body))
#+end_src

(TODO: TEST!!!)

Speaking of testing, here's a convenience macro for using =ert-deftest= with =pg-org-with-src-doc=.

#+name: src/org-deftest
#+begin_src emacs-lisp
  (defmacro pg-org-deftest (test-name block-name &rest body)
    "Use `pg-org-with-src-doc' to parse BLOCK-NAME into an
  org-element tree, then define an ERT test named TEST-NAME (using
  `ert-deftest') whose body is BODY."
    (declare (indent 2))
    `(pg-org-with-src-doc ,block-name
       (ert-deftest ,test-name () ,@body)))
#+end_src


** Org-ml as a template engine

=org-ml= has a regular convention for its constructures; for each element type /t/, a corresponding =org-ml= object can be created using =org-ml-t=.

This regularity permits a little hack, which in turn makes it possible to create a declarative tree of element names and parameters describing them, then later turn the tree into an =org-ml= object tree.

My main use for this has been to decrease clutter when I'm building an Org element tree or subtree from scratch, since this removes the need to type =org-ml-build-= before every type.

#+begin_src emacs-lisp

  (defun org-ml-normalize (tree)
    "Convert TREE into an org-ml build invocation, by prepending
    \"org-ml-build-\" to the symbol in first position of the
    list. This function is then applied recursively to all the tree
    node's children. (In this case, any lists contained in TREE
    whose first element is a symbol.) "
    ;; Only handle lists whose first element is a symbol
    (if (symbolp (car tree))
        ;; Normalize the root node
        (->> (cons (->> (car tree)
                        (symbol-name)
                        (concat "org-ml-build-")
                        (intern))
                   (cdr tree))
             ;; ...and its children
             (--map (if (listp it) (org-ml-normalize it) it)))
      tree))

  (defun org-ml-build (spec)
    "Transform SPEC into an org-element tree using constructors for
  elements in `org-ml'.

  All that is done to transform SPEC is that the first element of
  every list is prepended with \"org-ml-build-\" if it is a
  symbol. SPEC's format, then, is that of a tree of lists whose
  first elements are symbols representing element types; the rest
  of the elements are the arguments used to construct an element
  type using org-ml's corresponding \"org-ml-build-*\"
  corresponding to that symbol. A SPEC for a headline element, for
  instance, might be:

    (headline :title (secondary-string! \"foo\")
      (section (paragraph! \"paragraph text\")))

  This function will convert that specification into the result of
  calling:

    (org-ml-build-headline
      :title (org-ml-build-secondary-string! \"foo\")
      (org-ml-build-section
        (org-ml-build-paragraph! \"paragraph text\")))"
    (eval (org-ml-normalize spec)))
#+end_src


** Working with headlines

Many children of headlines can be useful to work with from the headline itself. This is especially true in =org-ml-match=, where it is often convenient to select a headline based on features of its children.

*** Logbook entries

Fetches the text of each logbook entry associated with =headline=, as a =paragraph= element. Keeping the =item= element it's associated with seems superfluous, it's just an =org-ml-build-item= away.

#+name: src/headline-logbook-entries
#+begin_src emacs-lisp
  (defun pg-org-headline-logbook-entries (headline)
    "Given a headline org element, return its logbook entries as a
    list of paragraph elements. If the headline doesn't contain any
    logbook entries, return `nil'."
    (->> headline
         (org-ml-match
          '(section
            (:and drawer (:drawer-name "LOGBOOK"))
            plain-list
            item
            paragraph))

         ))
#+end_src

Tested thusly:

#+name: input-logbook-simple
#+caption: Org document used in testing =pg-org-headline-logbook entries=
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :END:
    :LOGBOOK:
    - Top entry
    - Middle entry
    - Very first entry
    :END:
#+end_src

#+name: test-headline-logbook-entries
#+begin_src emacs-lisp :noweb eval :tangle no :results drawer
  <<src/headline-logbook-entries>>
  (require 's)

  (pg-org-deftest headline-logbook-entries/1 input-logbook-simple
    (let* ((entries (->> doc
                         (org-ml-match '(headline))
                         (first)
                         (pg-org-headline-logbook-entries)))
           (entry-strings (-map #'org-ml-to-trimmed-string entries)))
      (should (s-equals-p (nth 0 entry-strings) "Top entry"))
      (should (s-equals-p (nth 1 entry-strings) "Middle entry"))
      (should (s-equals-p (nth 2 entry-strings) "Very first entry"))

      (should (eq (nth 0 (nth 0 entries)) 'paragraph))
      (should (eq (nth 0 (nth 1 entries)) 'paragraph))
      (should (eq (nth 0 (nth 2 entries)) 'paragraph))))

  (pg-ert-run-tests-string "headline-logbook-entries/1")

#+end_src

*** Status changes

When configured to do so, Org will log changes between to-do keywords into the logbook. These logbook entries have a specific text format, but to Org it's still a single secondary string. This code parses that string and recovers the juicy data inside.

A previous version of this function lived in =pm.org= and took =item= elements instead of =paragraph= elements. This function works better with the output of the new and improved =pg-org-headline-logbook-entries=, however.

#+name: src/paragraph-parse-status-change
#+begin_src emacs-lisp :noweb eval :tangle no :exports code :results code
  (defun pg-org-paragraph-parse-status-change (para)
    "If PARA is a logbook entry that looks like it was generated
    when a to-do item's status changed, parse it and return a list of
    the state it was changed to (as a string), the state it was
    changed from (as a string), the timestamp, and an org paragraph
    element representing any additional notes provided by the
    user. Otherwise, return nil."
    (-when-let* [((_ _ s ts . the-rest)  para)
                 ;; parse out the to and from states
                 ((_ to from) (->> (org-ml-to-trimmed-string s)
                                   (s-match pg-pm-rx-logbook-resolved)))
                 ;; if notes exist, create as new paragraph
                 (notes (->> (if (org-ml-is-type 'line-break (first the-rest))
                                 ;; trick to inline (cdr the-rest) as args
                                 (let ((para-objs (-map (lambda (x) `(quote ,x)) (cdr the-rest))))
                                   (eval `(org-ml-build-paragraph ,@para-objs)))
                               ;; no additional notes == empty paragraph
                               (org-ml-build-paragraph))
                             (org-ml-remove-parents)))]
      (list to from (org-ml-remove-parents ts) notes)))
#+end_src

Tested thusly (TODO)


#+name: input-logbook-status-changes
#+caption: Sample used for testing
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :END:
    :LOGBOOK:
    - State "DOING"      from "BLOCKED"    [2021-12-11 Sat 20:06] \\
      Back on the case
    - State "BLOCKED"    from "DOING"      [2021-12-11 Sat 20:05] \\
      Waiting on parts from the supplier
    - State "DOING"      from "TODO"       [2021-12-11 Sat 20:04] \\
      In process, it's harder than it looks
    - Not a status update
    :END:
#+end_src

Note that =pg-org-paragraph-parse-status-change= returns =nil= if the parse fails, so the spurious additional item in the input is ignored

#+begin_src emacs-lisp :noweb eval :tangle no :results drawer
  <<src/paragraph-parse-status-change>>
  (require 'ts)

  (pg-org-deftest pg-org-paragraph-parse-status-change/t
      input-logbook-status-changes
    (let ((entries (->> doc
                        (org-ml-match '(headline))
                        (first)
                        (pg-org-headline-logbook-entries)
                        (-keep #'pg-org-paragraph-parse-status-change))))
      (pg-ert-shouldmap
          entries
          '(("BLOCKED" "DOING" "[2021-12-11 Sat 20:06]"
             "Back on the case")
            ("DOING" "BLOCKED" "[2021-12-11 Sat 20:05]"
             "Waiting on parts from the supplier")
            ("TODO" "DOING" "[2021-12-11 Sat 20:046]"
             "In process, it's harder than it looks"))
        (-let (((act-to act-from act-ts act-notes) act)
               ((exp-to exp-from exp-ts exp-notes) exp))
          (equal act-to exp-to)
          (equal act-from exp-from)
          (ts=  (ts-parse-org-element act-ts) (ts-parse-org exp-ts))
          (string-equal (org-ml-to-trimmed-string act-notes) exp-notes)))))

  (pg-ert-run-tests-string "paragraph-parse-status-change")

#+end_src


*** Lookahead matching

The =org-ml-match= function in Org-ML is very powerful, including a generalize =:pred= function that can match on a user-supplied predicate. Match predicates take a single argument representing the node currently being evaluated, and return =t= iff the node should match, whatever the predicate determines that to mean.

One limitation of =org-ml-match= predicates is a lack of "lookahead" a capability: There's no natural way to select a node based on the properties of the nodes it contains. One can build predicates that do this by, themselves, calling =org-ml-match=; this is inconvenient for ad-hoc matching.

The following is a way around that limitation. =pg-org-match-lookahead= takes a set of =org-ml-match= criteria /\kappa/ and returns a predicate that applies those criteria to the node under consideration–meaning, it's a predicate that asserts that there exists one or more child nodes beneath the current node that match /\kappa/.

#+name: lookahead-ex/1
#+begin_src org :results none :exports code :tangle no
  ,* Foo
  ,** Tasks
  ,* Bar
  ,** Tasks
  ,* Baz
  ,** Tasks
  ,* Additional notes
#+end_src

For example, consider the task of matching only the  headlines in Listing [[lookahead-ex/1]] that contain subheadings for tasks. As can be seen in Listing [[lookahead-ex/1.1]] the match criteria =(headline (:and headline (:raw-value "Tasks")))= will match the subheads, but not the tasks. (It is sometimes possible to backtrack to an ancestor from a child node, but not always and not reliably.)

#+name: lookahead-ex/1.1
#+begin_src emacs-lisp :results code :exports code :tangle no
  (pg-org-with-src-doc lookahead-ex/1
    (->> doc
         (org-ml-match '(headline (:and headline (:raw-value "Tasks"))))
         (-map #'org-ml-remove-parents)))
#+end_src

Using a lookahead predicate, however, it is possible to get the result we want, as in Listing [[lookahead-ex/1.2]].

#+name: lookahead-ex/1.2
#+begin_src emacs-lisp :results code :exports code :tangle no
  (defun my-task-predicate (node)
    (org-ml-match '((:and headline (:raw-value "Tasks"))) node))

  (pg-org-with-src-doc lookahead-ex/1
    (->> doc
         (org-ml-match '((:and headline (:pred my-task-predicate))))
         (-map #'org-ml-remove-parents)))
#+end_src

The tradeoff here is obviously recursion, but the maximum recursion here should be the maximum depth of the document tree, absent chicanery in the predicate like searching on a node's parent.

**** General-purpose lookahead
<<sct-gp-lookahead>>

We can and do define a generalized function for returning a lookahead-style match predicate. It's a simple partial application of =org-ml-match=.

#+name: src/lookahead
#+begin_src emacs-lisp
  (defun pg-org-lookahead (match-criteria)
    "Return a function that takes an org-element node and runs
    `org-ml-match' on it using MATCH-CRITERIA as the match
    criteria. Returns a true value if the match returns results,
    else `nil'."
    (-partial #'org-ml-match match-criteria))
#+end_src

This function is not as useful as we might wish, because the value of =:pred= must be a symbol, not an actual function. So the code in Listing [[lookahead-ex/2.1]] doesn't work.

#+name: lookahead-ex/2.1
#+begin_src emacs-lisp :results code :exports code :tangle no
  ;; This doesn't work....
  (pg-org-with-src-doc lookahead-ex/1
      (->> doc
           (org-ml-match `((:and headline
                                 (:pred ,(pg-org-lookahead
                                          '(:and headline (:raw-value "Tasks")))))))
           (-map #'org-ml-remove-parents)))
#+end_src


It can, however, be used somewhat awkwardly with =cl-letf=, as shown by the test in Listing [[test-lookahead]].


#+name: test-lookahead
#+begin_src emacs-lisp :exports code  :noweb eval :tangle no :results drawer
  <<src/lookahead>>


  (pg-org-deftest pg-org-lookahead/t
      lookahead-ex/1
    (cl-letf* (((symbol-function 'has-tasks)
                (lambda (el)
                  (pg-org-lookahead
                   '((:and headline (:raw-value "Tasks"))) el)))
               (results (org-ml-match '((:and headline (:pred has-tasks))) doc)))
      (pg-ert-shouldmap results '("Foo" "Bar" "Baz")
        (string-equal (org-ml-get-property :raw-value act) exp))))

  (pg-ert-run-tests-string "pg-org-lookahead/t")
#+end_src

**** =pg-org-match=

Using the =cl-letf= trick described in Section [[sct-gp-lookahead]], we can write a macro that extends =org-ml-match= with some new functionality.

First, we can implement a =:lookahead= selector that takes match criteria and applies it to the node using =pg-org-lookahead= using the =cl-letf= trick. That  will simplify the =org-ml-match= call in Listing [[test-lookahead]]
to the code in Listing [[pg-org-match-ex/lookahead]].

#+name: pg-org-match-ex/lookahead
#+begin_src emacs-lisp :exports code :tangle no
  (pg-org-match '((:and headline
                        (:lookahead
                         ((:and headline
                                (:raw-value "Tasks"))))))
                node)
#+end_src

We can also extend the match syntax in a very powerful way, with /anaphoric predicates/. This would permit a user to specify a predicate as arbitrary code in the match criterion itself. Consider, for instance, a selector for all timestamps after a certain time. Currently, candidate =timestamp= elements would be selected with =org-ml-match=, then filtered. With an anaphoric predicate, this could be declared in a single match structure.

#+name: pg-org-match-ex/anaphoric
#+begin_src emacs-lisp :exports code :tangle no
  ;; Only timestamps from the last 7 days
  (pg-org-match '((:and timestamp
                        (:-pred ((ts> (ts-parse-org-element el)
                                      (ts-adjust 'day -7 (ts-now)))))))
                node)
#+end_src

Some of this logic could still be encapsulated in a function, as shown in Listing [[pg-org-match-ex/anaphoric-fn]]. This increases readability and code reuse, as functions like =timestamp-within-last= could be used in many places.

#+name: pg-org-match-ex/anaphoric-fn
#+begin_src emacs-lisp :exports code :tangle no
  ;; Only timestamps from the last 7 days
  (defun timestamp-within-last (num unit el)
    (ts> (ts-parse-org-element el)
         (ts-adjust unit num (ts-now))))

  (pg-org-match '((:and timestamp (:-pred (timestamp-within-last 7 'day el))))
                node)
#+end_src

This would translate to the code in Listing [[pg-org-match-ex/anaphoric-unrolled]].

#+name: pg-org-match-ex/anaphoric-unrolled
#+begin_src emacs-lisp :exports code :tangle no
  ;; Only timestamps from the last 7 days
  (defun timestamp-within-last (num unit el)
    (ts> (ts-parse-org-element el)
         (ts-adjust unit num (ts-now))))

  (cl-letf* (((symbol-function 'a-predicate)
              (lambda (el)
                (timestamp-within-last 7 'day el))))
    (pg-org-match '((:and timestamp (:pred a-predicate))) node))
#+end_src

***** =pg-org--match-build-pattern=

The main work of the =pg-org-match= macro is done in =pg-org--match-build-pattern=, which recursively traverses a match pattern, making some transformations as necessary to add our new functionality. The code for this function is in [[src/pg-org--match-build-pattern]]. The input to =pg-org--match-build-pattern= is an =org-ml-match= pattern. The output is a double =(clauses pattern)=, which =pattern= is the original pattern transformed as necessary to enable our additional functionality, and =clauses= is a set of =(symbol function)= pairs. Using =cl-letf= and the =org-ml-match= =:pred= functionality, we can implement =:lookahead= and =:-pred= using only these additional functions and transformations.


#+name: src/pg-org--match-build-pattern
#+begin_src emacs-lisp
  (defun pg-org--match-build-pattern (pattern)
    (-let (((tok . rest) pattern))
      (case tok
        ;; The patterns we transform:
        ;; - :lookahead
        (:lookahead
         (progn
           ;;(message "FUCK: :lookahead %s %s" tok rest)
           (-let* ((sym (gensym "lookahead-"))
                   (clause
                    `((symbol-function ,sym) (lambda (el) (pg-org-lookahead ,(car rest) el))))
                   (new-pattern `(:pred ,sym)))
             (list (list clause) new-pattern))))
        ;; - :-pred
        (:-pred
         (progn
           (message "FUCK: :-pred %s %s" tok rest)
           (-let* ((sym (gensym "lookahead-"))
                   (clause
                    `((symbol-function ,sym) (lambda (el) ,(car rest))))
                   (new-pattern `(:pred ,sym)))
             (list (list clause) new-pattern))))
        ;; unary prefixes; leave them unchanged and consume rest of the list
        ((:first :last :and :or :not)
         (progn
           ;; (error "FUCK: :first :last :and :or :not")
           (-let (((clauses rest-pattern) (pg-org--match-build-pattern rest)))
             (list clauses (cons tok rest-pattern)))))
        ;; 2-ary prefixes
        (:nth
         (progn
           ;; (error "FUCK: :nth")
           (-let* (((x . rest) rest)
                   ((clauses rest-pattern) (pg-org--match-build-pattern rest)))
             (list clauses (-concat `(,tok ,x) rest-pattern)))))
        ;; 3-ary prefixes
        (:sub
         (progn
           ;; (error "FUCK: :sub")
           (-let* (((x y . rest) rest)
                   ((clauses rest-pattern) (pg-org--match-build-pattern rest)))
             (list clauses (-concat `(,tok ,x ,y) rest-pattern)))))
        ;; general case – if it's a list, modify it and consume the rest
        ;; of the list. If it's a symbol we don't need to modify, yield
        ;; it unchanged and consume the rest of the list.
        (t
         (cond
          ((listp tok)
           ;; Subpattern; get the clauses and new pattern associated
           ;; with it, and combine with the rest of the "horizontal"
           ;; pattern
           (progn
             (cond
              ;; base case
              ((eq nil tok)
               '(nil nil))
              ;; descend into list
              (t
               (-let* (((cl1 p1) (pg-org--match-build-pattern tok))
                       ((cl2 p2) (pg-org--match-build-pattern rest))
                       (new-clauses (-concat cl1 cl2))
                       (new-pattern (cons p1 p2)))
                 (list new-clauses new-pattern))))))

          ((symbolp tok)
           (cond
            ;; Property name (or any other special form org-ml-match
            ;; handles)
            ((s-starts-with? ":" (symbol-name tok))
             (progn
               (message "[symbol] TOK: %s" tok)
               (message "[symbol] REST: %s" rest)
               (list nil `(,tok ,@rest))))
            ;; Element name
            (t
             (progn
               (-let (((clauses pattern) (pg-org--match-build-pattern rest)))
                 (list clauses (cons tok pattern)))))))))
        )))
#+end_src

#+RESULTS: src/pg-org--match-build-pattern
: pg-org--match-build-pattern

****** Testing

The =pg-org--match-build-pattern= function makes a lot of decisions. Listing [[test/pg-org--match-build-pattern-1]] shows a unit test for basic functionality, demonstrating that the function can traverse the match structure non-destructively in the cases where it is just proxying =org-ml-match=.

#+name: pg-org--match-build-pattern-1
#+begin_src emacs-lisp :noweb yes :exports code :tangle no :results drawer
  <<src/pg-org--match-build-pattern>>

  (ert-deftest pg-org--match-build-pattern-1-t ()
    (cl-macrolet ((-? (test-form expected-value)
                      `(should (equal (pg-org--match-build-pattern ,test-form)
                                      ,expected-value))))
      (-? '()
          '(nil nil))

      (-? '(:nth 2 headline)
          '(nil (:nth 2 headline)))

      (-? '(:sub 1 2 headline)
          '(nil (:sub 1 2 headline)))

      (-? '(:drawer-name "LOGBOOK")
          '(nil (:drawer-name "LOGBOOK")))

      (-? '(headline section paragraph)
          '(nil (headline section paragraph)))

      (-? '(:and (:nth 2 section) headline)
          '(nil (:and (:nth 2 section) headline)))

      (-? '(:and (:sub 1 2 section) headline)
          '(nil (:and (:sub 1 2 section) headline)))

      (-? '(:and headline (:drawer-name "LOGBOOK"))
          '(nil (:and headline (:drawer-name "LOGBOOK"))))))

  (pg-ert-run-tests-string "pg-org--match-build-pattern-1-t")
#+end_src

Testing our added functionality is more challenging, as it introduces code containing unique symbols created with =gensym=. We can still make assertions about the structure of the output, however, as shown in [[test/pg-org--match-build-pattern-2]] and [[test/pg-org--match-build-pattern-3]].

#+name: pg-org--match-build-pattern-2
#+caption: Testing lookahead functionality in =pg-org--match-built-pattern=
#+begin_src emacs-lisp :noweb yes :exports code :tangle no :results drawer
  <<src/pg-org--match-build-pattern>>

  (ert-deftest pg-org--match-build-pattern-2-t ()
    (let ((output (pg-org--match-build-pattern '((:lookahead (headline))))))
      (let* ((sym (cadr (caaar output)))
             (fn  (cadaar output))
             (expected-fn '(lambda (el) (pg-org-lookahead (headline) el)))
             (expected `((((symbol-function ,sym) ,expected-fn)) ((:pred ,sym)))))
        (should (symbolp sym))
        (should (functionp fn))
        (should (equal fn expected-fn))
        (should (equal output expected)))))

  (pg-ert-run-tests-string "pg-org--match-build-pattern-2-t")
#+end_src

#+name: pg-org--match-build-pattern-3
#+caption: Testing anaphoric predicate functionality in =pg-org--match-built-pattern=
#+begin_src emacs-lisp :noweb yes :exports code :tangle no :results drawer
  <<src/pg-org--match-build-pattern>>

  (ert-deftest pg-org--match-build-pattern-3-t ()
    (let ((output (pg-org--match-build-pattern '((:-pred (equal (foo el) 1))))))
      (let* ((sym (cadr (caaar output)))
             (fn  (cadaar output))
             (expected-fn '(lambda (el) (equal (foo el) 1)))
             (expected `((((symbol-function ,sym) ,expected-fn)) ((:pred ,sym)))))
        (should (symbolp sym))
        (should (functionp fn))
        (should (equal fn expected-fn))
        (should (equal output expected)))))

  (pg-ert-run-tests-string "pg-org--match-build-pattern-3-t")
#+end_src

***** =pg-org-match=

Listing [[src/pg-org-match]] shows the very simple =pg-org-match= function. Clearly, all the heavy lifting is done in =pg-org--match-build-pattern=. This is the public entry point, however, so the function is well-documented.

#+name: src/pg-org-match
#+begin_src emacs-lisp
  (defmacro pg-org-match (pattern node)
    "Match PATTERN against NODE, in the form of `org-ml-match', but with a more powerful extended syntax.

  `pg-org-match' supports the following additional match patterns:

  `(:lookahead SUBPATTERN)' runs a second `org-ml-match' on the
  children of the current node, returning a true value if
  SUBPATTERN matches any of the node's children. In other words, it
  matches nodes based on the properties of the nodes' children. In
  this way, one can, say, match headlines with a LOGBOOK drawer
  with the following pattern:

    (:and headline
          (:lookahead (section (:and drawer
                                     (:drawer-name \"LOGBOOK\")))))

  `(:-pred CODE)' implements an anaphoric predicate. CODE is
  interpreted as the body of a lambda expression, which is called
  on a node using `(:pred ...)'. CODE may refer to the variable
  `el', which is the element currently being considered. Thus, the
  following code block:

    (cl-letf ((fn (lambda (el)
                     (org-ml-headline-has-tag \"work\" el))))
      (org-ml-match '((:pred fn)) node))


  Is equivalent to this call to `pg-org-match':

    (pg-org-match '((:-pred (org-ml-headline-has-tag \"work\" el))) node)

  In all other respects, this function is equivalent to a call to
  `org-ml-match'.
  "
    (-let (((clauses new-pattern) (pg-org--match-build-pattern pattern)))
      `(cl-letf ,clauses
         (org-ml-match ,new-pattern ,node))))
#+end_src

****** Testing

In Listing [[pg-org-match-1]], we do one last white-box test of the macro to ensure that it generates the kind of code we expect.

#+name: pg-org-match-1
#+caption: Testing pg-org-match
#+begin_src emacs-lisp :noweb yes :exports code :tangle no :results drawer
  <<src/pg-org--match-build-pattern>>
  <<src/pg-org-match>>

  (ert-deftest pg-org-match-t ()
    (let*  ((output (macroexpand-1
                     '(pg-org-match
                       ((:-pred (org-ml-headline-has-tag "work" el))) node)))
            (sym (cadr (caaadr output)))
            (expected `(cl-letf
                           (((symbol-function ,sym) (lambda (el)
                                    (org-ml-headline-has-tag "work" el))))
                         (org-ml-match ((:pred ,sym)) node))))
      (should (symbolp sym))
      (should (equal output expected))))

  (pg-ert-run-tests-string "pg-org-match-t")

#+end_src



* Provide

#+BEGIN_SRC emacs-lisp
  (provide 'pg-org)
  ;;; pg-org.el ends here
#+END_SRC
