#+STYLE: <link rel="stylesheet" type="text/css" href="style.css">
#+startup: indent
#+TITLE: pg-org.org: Customizations to org-mode

* Code

This library contains anything I may find specifically useful when working with Org Mode files, which I use constantly both in my regular workflow and as a literate programming tool.

** Package Header

#+name: src-header
#+BEGIN_SRC emacs-lisp
  ;;; pg-org.el --- Customizations to org-mode

  ;; Copyright (C) 2021 Phil Groce

  ;; Author: Phil Groce <pgroce@gmail.com>
  ;; Version: 0.2.2
  ;; Package-Requires: ((emacs "26.1") (org-ml "5.7") (dash "2.19") (s "1.12") (ts "0.3") (pg-ert "0.1"))
  ;; Keywords: productivity
#+END_SRC


** Requires

#+name: src-requires
#+begin_src emacs-lisp
  (require 'org-ml)
  (require 'dash)
  (require 's)
  (require 'ts)
#+end_src

** Working on Source Blocks

Being able to easily operate on blocks comes up during testing, and also in workflows where the Org file is being treated like an executable notebook. (See also: [[https://jupyter.org/][Jupyter Notebook]])

It should be easy to generalize this to all Org blocks, or even all named elements. I'm not inclined to do that right now, but the names of all the org elements types are in =org-element-all-elements= in =org-element.el=. (Not all of those can be named, however.)

#+name: src-pg-with-src
#+begin_src emacs-lisp :results silent
  (defmacro pg-org-with-src (block-name &rest body)
    "Put the text in the source block BLOCK-NAME in a temp buffer,
  then execute BODY in that buffer."
    (declare (indent 1))
    (let ((-src (make-symbol "-src")))
      `(cl-flet ((-assert (msg arg) (if (eq nil arg) (error msg) arg)))
         (let ((,-src

                (->> (org-ml-parse-this-buffer)
                     (org-ml-match
                      '(:any * (:and
                                src-block
                                (:name ,(symbol-name block-name)))))
                     (-assert (format "No src block %s" ,(symbol-name block-name)))
                     (car)
                     (org-ml-get-property :value))))
           ;;  Put the source block in a separate buffer and run the code in body
           (with-temp-buffer
             (insert ,-src)
             ,@body)))))


  (defmacro pg-org-with-src-doc (block-name &rest body)
    "Parse the text in the org-mode source block BLOCK-NAME into an
    org-element tree and run BODY. Code in BODY can refer to the
    org-element tree via the symbol `doc'."
    (declare (indent 1))
    `(lexical-let ((doc (pg-org-with-src ,block-name
                          (org-unescape-code-in-region (point-min) (point-max))
                          (org-do-remove-indentation)
                          (org-mode)
                          (org-ml-parse-this-buffer))))
       ,@body))
#+end_src

(TODO: TEST!!!)

Speaking of testing, here's a convenience macro for using =ert-deftest= with =pg-org-with-src-doc=.

#+name: src-org-deftest
#+begin_src emacs-lisp
  (defmacro pg-org-deftest (test-name block-name &rest body)
    "Use `pg-org-with-src-doc' to parse BLOCK-NAME into an
  org-element tree, then define an ERT test named TEST-NAME (using
  `ert-deftest') whose body is BODY."
    (declare (indent 2))
    `(pg-org-with-src-doc ,block-name
       (ert-deftest ,test-name () ,@body)))
#+end_src


** Org-ml as a template engine

=org-ml= has a regular convention for its constructures; for each element type /t/, a corresponding =org-ml= object can be created using =org-ml-t=.

This regularity permits a little hack, which in turn makes it possible to create a declarative tree of element names and parameters describing them, then later turn the tree into an =org-ml= object tree.

My main use for this has been to decrease clutter when I'm building an Org element tree or subtree from scratch, since this removes the need to type =org-ml-build-= before every type.

#+begin_src emacs-lisp

  (defun org-ml-normalize (tree)
    "Convert TREE into an org-ml build invocation, by prepending
    \"org-ml-build-\" to the symbol in first position of the
    list. This function is then applied recursively to all the tree
    node's children. (In this case, any lists contained in TREE
    whose first element is a symbol.) "
    ;; Only handle lists whose first element is a symbol
    (if (symbolp (car tree))
        ;; Normalize the root node
        (->> (cons (->> (car tree)
                        (symbol-name)
                        (concat "org-ml-build-")
                        (intern))
                   (cdr tree))
             ;; ...and its children
             (--map (if (listp it) (org-ml-normalize it) it)))
      tree))

  (defun org-ml-build (spec)
    "Transform SPEC into an org-element tree using constructors for
  elements in `org-ml'.

  All that is done to transform SPEC is that the first element of
  every list is prepended with \"org-ml-build-\" if it is a
  symbol. SPEC's format, then, is that of a tree of lists whose
  first elements are symbols representing element types; the rest
  of the elements are the arguments used to construct an element
  type using org-ml's corresponding \"org-ml-build-*\"
  corresponding to that symbol. A SPEC for a headline element, for
  instance, might be:

    (headline :title (secondary-string! \"foo\")
      (section (paragraph! \"paragraph text\")))

  This function will convert that specification into the result of
  calling:

    (org-ml-build-headline
      :title (org-ml-build-secondary-string! \"foo\")
      (org-ml-build-section
        (org-ml-build-paragraph! \"paragraph text\")))"
    (eval (org-ml-normalize spec)))
#+end_src


** Working with headlines

Many children of headlines can be useful to work with from the headline itself. This is especially true in =org-ml-match=, where it is often convenient to select a headline based on features of its children.

*** Logbook entries

Fetches the text of each logbook entry associated with =headline=, as a =paragraph= element. Keeping the =item= element it's associated with seems superfluous, it's just an =org-ml-build-item= away.

#+name: src-headline-logbook-entries
#+begin_src emacs-lisp
  (defun pg-org-headline-logbook-entries (headline)
    "Given a headline org element, return its logbook entries as a
    list of paragraph elements. If the headline doesn't contain any
    logbook entries, return `nil'."
    (->> headline
         (org-ml-match
          '(section
            (:and drawer (:drawer-name "LOGBOOK"))
            plain-list
            item
            paragraph))

         ))
#+end_src

Tested thusly:

#+name: input-logbook-simple
#+caption: Org document used in testing =pg-org-headline-logbook entries=
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :END:
    :LOGBOOK:
    - Top entry
    - Middle entry
    - Very first entry
    :END:
#+end_src

#+name: test-headline-logbook-entries
#+begin_src emacs-lisp :noweb eval :tangle no :results drawer
  <<src-headline-logbook-entries>>
  (require 's)

  (pg-org-deftest headline-logbook-entries/1 input-logbook-simple
    (let* ((entries (->> doc
                         (org-ml-match '(headline))
                         (first)
                         (pg-org-headline-logbook-entries)))
           (entry-strings (-map #'org-ml-to-trimmed-string entries)))
      (should (s-equals-p (nth 0 entry-strings) "Top entry"))
      (should (s-equals-p (nth 1 entry-strings) "Middle entry"))
      (should (s-equals-p (nth 2 entry-strings) "Very first entry"))

      (should (eq (nth 0 (nth 0 entries)) 'paragraph))
      (should (eq (nth 0 (nth 1 entries)) 'paragraph))
      (should (eq (nth 0 (nth 2 entries)) 'paragraph))))

  (pg-ert-run-tests-string "headline-logbook-entries/1")

#+end_src

*** Status changes

When configured to do so, Org will log changes between to-do keywords into the logbook. These logbook entries have a specific text format, but to Org it's still a single secondary string. This code parses that string and recovers the juicy data inside.

A previous version of this function lived in =pm.org= and took =item= elements instead of =paragraph= elements. This function works better with the output of the new and improved =pg-org-headline-logbook-entries=, however.

#+name: src-paragraph-parse-status-change
#+begin_src emacs-lisp :noweb eval :tangle no :exports code :results code
  (defun pg-org-paragraph-parse-status-change (para)
    "If PARA is a logbook entry that looks like it was generated
    when a to-do item's status changed, parse it and return a list of
    the state it was changed to (as a string), the state it was
    changed from (as a string), the timestamp, and an org paragraph
    element representing any additional notes provided by the
    user. Otherwise, return nil."
    (-when-let* [((_ _ s ts . the-rest)  para)
                 ;; parse out the to and from states
                 ((_ to from) (->> (org-ml-to-trimmed-string s)
                                   (s-match pg-pm-rx-logbook-resolved)))
                 ;; if notes exist, create as new paragraph
                 (notes (->> (if (org-ml-is-type 'line-break (first the-rest))
                                 ;; trick to inline (cdr the-rest) as args
                                 (let ((para-objs (-map (lambda (x) `(quote ,x)) (cdr the-rest))))
                                   (eval `(org-ml-build-paragraph ,@para-objs)))
                               ;; no additional notes == empty paragraph
                               (org-ml-build-paragraph))
                             (org-ml-remove-parents)))]
      (list to from (org-ml-remove-parents ts) notes)))
#+end_src

Tested thusly (TODO)


#+name: input-logbook-status-changes
#+caption: Sample used for testing
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :END:
    :LOGBOOK:
    - State "DOING"      from "BLOCKED"    [2021-12-11 Sat 20:06] \\
      Back on the case
    - State "BLOCKED"    from "DOING"      [2021-12-11 Sat 20:05] \\
      Waiting on parts from the supplier
    - State "DOING"      from "TODO"       [2021-12-11 Sat 20:04] \\
      In process, it's harder than it looks
    - Not a status update
    :END:
#+end_src

Note that =pg-org-paragraph-parse-status-change= returns =nil= if the parse fails, so the spurious additional item in the input is ignored

#+begin_src emacs-lisp :noweb eval :tangle no :results drawer
  <<src-paragraph-parse-status-change>>
  (require 'ts)

  (pg-org-deftest pg-org-paragraph-parse-status-change/t
      input-logbook-status-changes
    (let ((entries (->> doc
                        (org-ml-match '(headline))
                        (first)
                        (pg-org-headline-logbook-entries)
                        (-keep #'pg-org-paragraph-parse-status-change))))
      (pg-ert-shouldmap
          entries
          '(("BLOCKED" "DOING" "[2021-12-11 Sat 20:06]"
             "Back on the case")
            ("DOING" "BLOCKED" "[2021-12-11 Sat 20:05]"
             "Waiting on parts from the supplier")
            ("TODO" "DOING" "[2021-12-11 Sat 20:046]"
             "In process, it's harder than it looks"))
        (-let (((act-to act-from act-ts act-notes) act)
               ((exp-to exp-from exp-ts exp-notes) exp))
          (equal act-to exp-to)
          (equal act-from exp-from)
          (ts=  (ts-parse-org-element act-ts) (ts-parse-org exp-ts))
          (string-equal (org-ml-to-trimmed-string act-notes) exp-notes)))))

  (pg-ert-run-tests-string "paragraph-parse-status-change")

#+end_src


*** Lookahead matching

The =org-ml-match= function in Org-ML is very powerful, including a generalize =:pred= function that can match on a user-supplied predicate. Match predicates take a single argument representing the node currently being evaluated, and return =t= iff the node should match, whatever the predicate determines that to mean.

One limitation of =org-ml-match= predicates is a lack of "lookahead" a capability: There's no natural way to select a node based on the properties of the nodes it contains. One can build predicates that do this by, themselves, calling =org-ml-match=; this is inconvenient for ad-hoc matching.

The following is a way around that limitation. =pg-org-match-lookahead= takes a set of =org-ml-match= criteria /\kappa/ and returns a predicate that applies those criteria to the node under consideration–meaning, it's a predicate that asserts that there exists one or more child nodes beneath the current node that match /\kappa/.

#+name: lookahead-ex/1
#+begin_src org :results none :exports code :tangle no
  ,* Foo
  ,** Tasks
  ,* Bar
  ,** Tasks
  ,* Baz
  ,** Tasks
  ,* Additional notes
#+end_src

For example, consider the task of matching only the  headlines in Example [[lookahead-ex/1]] that contain subheadings for tasks. As can be seen in [[lookahead-ex/1.1]] the match criteria =(headline (:and headline (:raw-value "Tasks")))= will match the subheads, but not the tasks. (It is sometimes possible to backtrack to an ancestor from a child node, but not always and not reliably.)

#+name: lookahead-ex/1.1
#+begin_src emacs-lisp :results code :exports code :tangle no
  (pg-org-with-src-doc lookahead-ex/1
    (->> doc
         (org-ml-match '(headline (:and headline (:raw-value "Tasks"))))
         (-map #'org-ml-remove-parents)))
#+end_src

Using a lookahead predicate, however, it is possible to get the result we want, as in [[lookahead-ex/1.2]].

#+name: lookahead-ex/1.2
#+begin_src emacs-lisp :results code :exports code :tangle no
  (defun my-task-predicate (node)
    (org-ml-match '((:and headline (:raw-value "Tasks"))) node))

  (pg-org-with-src-doc lookahead-ex/1
    (->> doc
         (org-ml-match '((:and headline (:pred my-task-predicate))))
         (-map #'org-ml-remove-parents)))
#+end_src

The tradeoff here is obviously recursion, but the maximum recursion here should be the maximum depth of the document tree, absent chicanery in the predicate like searching on a node's parent.

**** General-purpose lookahead

We can and do define a generalized function for returning a lookahead-style match predicate. It's a simple partial application of =org-ml-match=.

#+name: src-lookahead
#+begin_src emacs-lisp
  (defun pg-org-lookahead (match-criteria)
    "Return a function that takes an org-element node and runs
    `org-ml-match' on it using MATCH-CRITERIA as the match
    criteria. Returns a true value if the match returns results,
    else `nil'."
    (-partial #'org-ml-match match-criteria))
#+end_src

This function is not as useful as we might wish, because the value of =:pred= must be a symbol, not an actual function. So the code in [[lookahead-ex/2.1]] doesn'twork.

#+name: lookahead-ex/2.1
#+begin_src emacs-lisp :results code :exports code :tangle no
  ;; This doesn't work....
  (pg-org-with-src-doc lookahead-ex/1
      (->> doc
           (org-ml-match `((:and headline
                                 (:pred ,(pg-org-lookahead
                                          '(:and headline (:raw-value "Tasks")))))))
           (-map #'org-ml-remove-parents)))
#+end_src


It can, however, be used somewhat awkwardly with =cl-letf=, as shown in the example [[lookahead-ex/2.2]].

#+name: lookahead-ex/2.2
#+begin_src emacs-lisp :results code :exports code :noweb eval :tangle no
  <<src-lookahead>>

  (pg-org-with-src-doc lookahead-ex/1
        (cl-letf* (((symbol-function 'has-tasks)
                    (pg-org-lookahead '((:and headline (:raw-value "Tasks"))))))
          (org-ml-match '((:and headline (:pred has-tasks))) doc)))
#+end_src


#+name: test-lookahead
#+begin_src emacs-lisp  :noweb eval :tangle no :results drawer
  <<src-lookahead>>


  (pg-org-deftest pg-org-lookahead/t
      lookahead-ex/1
     (cl-letf* (((symbol-function 'has-tasks) (pg-org-lookahead
                                               '((:and headline (:raw-value "Tasks")))))
                (results (org-ml-match '((:and headline (:pred has-tasks))) doc)))
       (pg-ert-shouldmap results '("Foo" "Bar" "Baz")
         (string-equal (org-ml-get-property :raw-value act) exp))))

  (pg-ert-run-tests-string "pg-org-lookahead/t")
#+end_src

* Provide

#+BEGIN_SRC emacs-lisp
  (provide 'pg-org)
  ;;; pg-org.el ends here
#+END_SRC
