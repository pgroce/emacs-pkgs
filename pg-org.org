#+STYLE: <link rel="stylesheet" type="text/css" href="style.css">
#+startup: indent
#+TITLE: pg-org.org: Customizations to org-mode

* Code

This library contains anything I may find specifically useful when working with Org Mode files, which I use constantly both in my regular workflow and as a literate programming tool.

** Package Header

#+name: src/header
#+BEGIN_SRC emacs-lisp
  ;;; pg-org.el --- Customizations to org-mode

  ;; Copyright (C) 2022 Phil Groce

  ;; Author: Phil Groce <pgroce@gmail.com>
  ;; Version: 0.3.7
  ;; Package-Requires: ((emacs "26.1") (org-ml "5.7") (dash "2.19") (s "1.12") (ts "0.3") (pg-ert "0.1"))
  ;; Keywords: productivity
#+END_SRC


** Requires

#+name: src/requires
#+begin_src emacs-lisp
  (eval-when-compile (require 'cl-macs))
  (require 'org-ml)
  (require 'dash)
  (require 's)
  (require 'ts)
#+end_src

** Working on Source Blocks

Being able to easily operate on blocks comes up during testing, and also in workflows where the Org file is being treated like an executable notebook. (See also: [[https://jupyter.org/][Jupyter Notebook]])

It should be easy to generalize this to all Org blocks, or even all named elements. I'm not inclined to do that right now, but the names of all the org elements types are in =org-element-all-elements= in =org-element.el=. (Not all of those can be named, however.)

#+name: src/pg-with-src
#+begin_src emacs-lisp :results silent
  (defmacro pg-org-with-src (block-name &rest body)
    "Put the text in the source block BLOCK-NAME in a temp buffer,
  then execute BODY in that buffer."
    (declare (indent 1))
    (let ((-src (make-symbol "-src")))
      `(cl-flet ((-assert (msg arg) (if (eq nil arg) (error msg) arg)))
         (let ((,-src

                (->> (org-ml-parse-this-buffer)
                     (org-ml-match
                      '(:any * (:and
                                src-block
                                (:name ,(symbol-name block-name)))))
                     (-assert (format "No src block %s" ,(symbol-name block-name)))
                     (car)
                     (org-ml-get-property :value))))
           ;;  Put the source block in a separate buffer and run the code in body
           (with-temp-buffer
             (insert ,-src)
             ,@body)))))


  (defmacro pg-org-with-src-doc (block-name &rest body)
    "Parse the text in the org-mode source block BLOCK-NAME into an
    org-element tree and run BODY. Code in BODY can refer to the
    org-element tree via the symbol `doc'."
    (declare (indent 1))
    `(lexical-let ((doc (pg-org-with-src ,block-name
                          (org-unescape-code-in-region (point-min) (point-max))
                          (org-do-remove-indentation)
                          (org-mode)
                          (org-ml-parse-this-buffer))))
       ,@body))
#+end_src

(TODO: TEST!!!)

Speaking of testing, here's a convenience macro for using =ert-deftest= with =pg-org-with-src-doc=.

#+name: src/org-deftest
#+begin_src emacs-lisp
  (defmacro pg-org-deftest (test-name block-name &rest body)
    "Use `pg-org-with-src-doc' to parse BLOCK-NAME into an
  org-element tree, then define an ERT test named TEST-NAME (using
  `ert-deftest') whose body is BODY."
    (declare (indent 2))
    `(pg-org-with-src-doc ,block-name
       (ert-deftest ,test-name () ,@body)))
#+end_src


** Org-ml as a template engine

=org-ml= has a regular convention for its constructors; for each element type /t/, a corresponding =org-ml= object can be created using =org-ml-t=. Since lisp code is data, and since there are Org-ml builders for every org element type, this means we use these constructors as a kind of simplified DSL for specifying Org documents or, more powerfully, templates.

As an example, consider Listing [[ex/org-ml-build/1/code]], which is code for building a very simple document with one headline. If name is "Phil", this will generate the Org document in [[ex/org-ml-build/1/results]].

#+name: ex/org-ml-build/1/code
#+begin_src emacs-lisp :tangle no
  (defun hello-org (name)
    (list (org-ml-build-section
           (org-ml-build-headline
            :title (format "Hello %s!" name)
            (org-ml-build-section
             (org-ml-build-paragraph! "Hi there!"))))))
#+end_src

#+name: ex/org-ml-build/1/results
#+begin_src org :tangle no
  ,* Hello Phil
    Hi there!
#+end_src

There is a lot of duplication in the nested calls to =org-ml-build-*= functions; it would be nice to remove that. But beyond that, imagine treating that set of =build= calls as a template, as in Listing [[ex/org-ml-build/2/code]].

#+name: ex/org-ml-build/2/code
#+begin_src emacs-lisp :tangle no
  (let ((hello-org-template
         '(org-ml-build-section
           (org-ml-build-headline :title name)))
        (name "Phil"))
    (eval hello-org-template))
#+end_src

Lisp is beautiful. Perhaps, however, it can be made moreso. There's a lot of duplication in =hello-org-template=, ideally it could be written as it is in Listing [[ex/org-ml-build/3/code]].

#+name: ex/org-ml-build/3/code
#+begin_src emacs-lisp :tangle no
  (let ((hello-org-template
         '(section (headline :title name)))
        (name "Phil"))
    (eval hello-org-template))
#+end_src

We can't, of course, pass =hello-org-template= to =eval= as we have done here. But if we precede that evaluation with a transformation of =hello-org-template= to restore the =org-ml-build-= prefix, we certainly can. This is the purpose of =pg-org-build=.

#+name: src/org-ml-build
#+begin_src emacs-lisp
  (defun pg-org--ml-build-spec (spec)
    "Build the input to `org-ml-build' from `spec'."
    (pg-util-tree-transform-2
     spec
     :transformer
     (lambda (node)
       (let ((head (car node)))
         (cond
          ((not (symbolp head))
           (error "Unexpected non-symbol %s" head))
          ((eq head 'quote)
           `(:node ,node :stop t))
          (t
           (let* ((new-name (format "org-ml-build-%s" (symbol-name head)))
                  (new-sym (intern-soft new-name)))
             (if (not new-sym)
                 (error "Void function: %s" new-name)
               `(:node ,(cons new-sym (cdr node)))))))))))


  (defun pg-org-ml-build (spec)
    "Transform SPEC into an org-element tree using constructors for
  elements in `org-ml'.

  All that is done to transform SPEC is that the first element of
  every list is prepended with \"org-ml-build-\" if it is a
  symbol. SPEC's format, then, is that of a tree of lists whose
  first elements are symbols representing element types; the rest
  of the elements are the arguments used to construct an element
  type using org-ml's corresponding \"org-ml-build-*\"
  corresponding to that symbol. A SPEC for a headline element, for
  instance, might be:

    (headline :title (secondary-string! \"foo\")
      (section (paragraph! \"paragraph text\")))

  This function will convert that specification into the result of
  calling:

    (org-ml-build-headline
      :title (org-ml-build-secondary-string! \"foo\")
      (org-ml-build-section
        (org-ml-build-paragraph! \"paragraph text\")))"
    (eval (pg-org--ml-build-spec spec)))

  (defalias 'org-ml-build 'pg-org-ml-build)
#+end_src

#+RESULTS: src/org-ml-build
: org-ml-build

The code in Listing [[ex/org-ml-build/4]] demonstrates the usage of =pg-org-ml-build=.

#+name: ex/org-ml-build/4
#+begin_src emacs-lisp :tangle no :results code :wrap src emacs-lisp :noweb yes
  <<src/org-ml-build>>

  (pg-org-ml-build '(timestamp! '(2019 1 1 0 0)))
#+end_src



** Working with headlines

Many children of headlines can be useful to work with from the headline itself. This is especially true in =org-ml-match=, where it is often convenient to select a headline based on features of its children.

*** Logging configuration

Several Org-ML functions related to headlines require the user to supply a logging configuration, specifying which drawer is the logbook drawer and whether to put clocks in the drawer. There are lots of good reasons for that. Perhaps the best is that the rules for determining a headline's logging configuration depend on context like a node's inherited properties; for a function operating on fragments of Org trees in isolation, there is no way to conclude what those are with any certainty. Passing the configuration also removes a source of side-effects, making the functions more generally useful.

All that said, these configurations seldom change for most people. An interface that hides the configuration information is clearer and, for most uses, quite adequate. For those who with to trade some possible inaccuracy and purity for simplicity, this package provides a set of complementary functions to those in Org-ML for handling headline contents and logbooks that don't require the user to pass configuration information. Instead, custom variable holds this information; proxy functions use this variable for configuration information. No other changes are made, both because they aren't required, and to facilitate switching over to the more fundamental functions if necessary.

Org-ML defines one more function in this category, =org-ml-headline-logbook-convert-config=, which doesn't make sense to proxy here for obvious reasons.

#+name: src/logging-configuration
#+begin_src emacs-lisp
  (defcustom pg-org-headline-logging-config
    '(:log-into-drawer "LOGBOOK" :clock-into-drawer t)
    "Default logging format for Org files."
    :type '(plist)
    :group 'pm)

  (defun pg-org-get-log-into-drawer ()
    (plist-get pg-org-headline-logging-config :log-into-drawer))

  (defun pg-org-get-clock-into-drawer ()
    (plist-get pg-org-headline-logging-config :clock-into-drawer))

  ;; Supercontents

  (defun pg-org-headline-get-supercontents (headline)
    "Use `org-ml-headline-get-supercontents' to return the
    supercontents of HEADLINE. Uses
    `pg-org-headline-logging-config' for logging configuration
    information."
    (org-ml-headline-get-supercontents
     pg-org-headline-logging-config headline))

  (defun pg-org-headline-set-supercontents (supercontents headline)
    "Use `org-ml-headline-set-supercontents' to set the
    supercontents of HEADLINE. Uses
    `pg-org-headline-logging-config' for logging configuration
    information."
    (org-ml-headline-set-supercontents
     pg-org-headline-logging-config supercontents headline))

  (defun pg-org-headline-map-supercontents (fun headline)
    "Use `org-ml-headline-map-supercontents' to map the
    supercontents of HEADLINE. Uses
    `pg-org-headline-logging-config' for logging configuration
    information."
    (org-ml-headline-map-supercontents
        pg-org-headline-logging-config fun headline))


  ;; Logbook items

  (defun pg-org-headline-get-logbook-items (headline)
    "Use `org-ml-headline-get-logbook-items' to pull logbook items
    off HEADLINE. Uses `pg-org-headline-logging-config' for logging
    configuration information."
    (org-ml-headline-get-logbook-items
     pg-org-headline-logging-config
     headline))

  (defun pg-org-headline-set-logbook-items (items headline)
    "Use `org-ml-headline-set-logbook-items' to set logbook items
    for HEADLINE. Uses `pg-org-headline-logging-config' for logging
    configuration information."
    (org-ml-headline-set-logbook-items
     pg-org-headline-logging-config
     items
     headline))

  (defun pg-org-headline-map-logbook-items (fun headline)
    "Use `org-ml-headline-map-logbook-items' to set logbook items
    for HEADLINE. Uses `pg-org-headline-logging-config' for logging
    configuration information."
    (org-ml-headline-map-logbook-items
     pg-org-headline-logging-config
     fun
     headline))


  ;; Logbook clocks

  (defun pg-org-headline-get-logbook-clocks (headline)
    "Use `org-ml-headline-get-logbook-clocks' to pull logbook clocks
    off HEADLINE. Uses `pg-org-headline-logging-config' for logging
    configuration information."
    (org-ml-headline-get-logbook-clocks
     pg-org-headline-logging-config
     headline))

  (defun pg-org-headline-set-logbook-clocks (clocks headline)
    "Use `org-ml-headline-set-logbook-clocks' to set logbook clocks
    for HEADLINE. Uses `pg-org-headline-logging-config' for logging
    configuration information."
    (org-ml-headline-set-logbook-clocks
     pg-org-headline-logging-config
     clocks
     headline))

  (defun pg-org-headline-map-logbook-clocks (fun headline)
    "Use `org-ml-headline-map-logbook-clocks' to set logbook clocks
    for HEADLINE. Uses `pg-org-headline-logging-config' for logging
    configuration information."
    (org-ml-headline-map-logbook-clocks
     pg-org-headline-logging-config
     fun
     headline))



  ;; Contents


  (defun pg-org-headline-get-contents (headline)
    "Use `org-ml-headline-get-contents' to return the contents of
    HEADLINE. Uses `pg-org-headline-logging-config' for logging
    configuration information."
    (org-ml-headline-get-contents
     pg-org-headline-logging-config headline))

  (defun pg-org-headline-set-contents (contents headline)
    "Use `org-ml-headline-set-contents' to set the contents of
    HEADLINE. Uses `pg-org-headline-logging-config' for logging
    configuration information."
    (org-ml-headline-set-contents
     pg-org-headline-logging-config contents headline))

  (defun pg-org-headline-map-contents (fun headline)
    "Use `org-ml-headline-map-contents' to map the contents of
    HEADLINE. Uses `pg-org-headline-logging-config' for logging
    configuration information."
    (org-ml-headline-map-contents
        pg-org-headline-logging-config fun headline))

  ;; Other logbook

  (defun pg-org-headline-logbook-append-item (item headline)
    "Use `org-ml-headline-append-item' to return the contents
    of HEADLINE. Uses `pg-org-headline-logging-config' for logging
    configuration information."
    (org-ml-headline-logbook-append-item
     pg-org-headline-logging-config item headline))

  (defun pg-org-headline-logbook-append-open-clock (unixtime note headline)
    "Use `org-ml-headline-logbook-append-open-clock' to add an open
    clock into the logbook of HEADLINE. Uses
    `pg-org-headline-logging-config' for logging configuration
    information."
    (org-ml-headline-logbook-append-open-clock
     pg-org-headline-logging-config unixtime headline))

  (defun pg-org-headline-logbook-close-open-clock (unixtime note headline)
    "Use `org-ml-headline-logbook-close-open-clock' to close an
    open clock in the logbook of HEADLINE. Uses
    `pg-org-headline-logging-config' for logging configuration
    information."
    (org-ml-headline-logbook-close-open-clock
     pg-org-headline-logging-config unixtime note headline))

#+end_src


*** Logbook access

Syntactically, a logbook is just a =drawer= containing an itemized list of entries, and that's the only interface Org-ML provides to it, with some limited exceptions Semantically, it's an event log. The following code provides an interface for working with logbooks that considers it at that level.

A logbook has the structure shown in Listing [[ex/logbook-structure]]: A =drawer= containing a =plain-list= and a set of items. The items are frequently formatted specially as well.

#+name ex/logbook-structure
#+begin_src emacs-lisp
  (drawer
   (plain-list
    (item (paragraph))
    (item (paragraph))
    (item (paragraph))))
#+end_src


#+name: src/logbook
#+begin_src emacs-lisp
  (defun pg-org-logbook ()
    "Create a new, empty logbook drawer as an Org element."
    (org-ml-build-drawer (pg-org-get-log-into-drawer)))

  ;; Constructors

  (defun pg-org-logbook-from-plain-list (plain-list)
    "Create a logbook using `pg-org-logbook', whose child is
  PLAIN-LIST."
    (->> (pg-org-logbook)
         (org-ml-set-children (list plain-list))))

  (defun pg-org-logbook-from-items (items)
    "Create a logbook using `pg-org-logbook-from-plain-list',
  containing ITEMS in its enclosed list."
    (let ((plain-list (->> (org-ml-build-plain-list)
                           (org-ml-set-children items))))
      (pg-org-logbook-from-plain-list plain-list)))

  (defun pg-org-logbook-from-paragraphs (paragraphs)
    "Create a logbook using `pg-org-logbook-from-items', with each
  paragraph in PARAGRAPH enclosed in an item."
    (->> (--map (org-ml-build-item it) paragraphs)
         (pg-org-logbook-from-items)))

  (defun pg-org-logbook-from-strings (strings)
    "Create a logbook using `pg-org-logbook-from-paragraphs', with
    each string in STRINGS enclosed in a paragraph element."
    (->> (--map (org-ml-build-paragraph! it) strings)
         (pg-org-logbook-from-paragraphs)))


  ;; Accessors
  (defun pg-org-logbook-get-plain-list (logbook)
    "Get the contents of LOGBOOK as a plain-list Org element."
    (->> (org-ml-get-children logbook)
         (nth 0)))

  (defun pg-org-logbook-get-items (logbook)
    "Get the contents of LOGBOOK as a list of item elements."
    (->> (pg-org-logbook-get-plain-list logbook)
         (org-ml-get-children)))

  (defun pg-org-logbook-get-paragraphs (logbook)
    "Get the contents of LOGBOOK as a list of paragraph elements."
    (--map (->> (org-ml-get-children it)
                (nth 0))
           (pg-org-logbook-get-items logbook)))

  (defun pg-org-logbook-get-strings (logbook)
    "Get the contents of LOGBOOK as a list of strings."
    (->> (pg-org-logbook-get-paragraphs logbook)
         (-map #'org-ml-to-trimmed-string)))

  ;; Mutators

  (defun pg-org-logbook-prepend-item (item logbook)
    "Return new logbook based on LOGBOOK with ITEM prepended to the
  beginning (top) of the list of items."
    (->> (pg-org-logbook-get-items logbook)
         (cons item)
         (pg-org-logbook-from-items)))

  (defun pg-org-logbook-prepend-paragraph (paragraph logbook)
    "Return new logbook with PARAGRAPH wrapped in an item element
  and prepended to the plain-list in LOGBOOK using
  `pg-org-logbook-prepend-item'."
    (pg-org-logbook-prepend-item (org-ml-build-item! paragraph) logbook))

  (defun pg-org-logbook-prepend-string (s logbook)
    "Return new logbook with S wrapped in a paragraph element and
    prepended to LOGBOOK using
    `pg-org-logbook-prepend-paragraph'. S is enclosed in a
    paragraph using `org-ml-build-paragraph!', so formatting can be
    used in the string."
  (pg-org-logbook-prepend-paragraph (org-ml-build-paragraph! s) logbook))

  (defun pg-org-logbook-prepend-secondary-string (ss logbook)
    "Return new logbook with SS wrapped in a paragraph element and
    item and prepended to LOGBOOK using
    `pg-org-logbook-prepend-item'."
    (->> (org-ml-build-item)
         (org-ml-item-set-paragraph ss)
         (funcall (-flip #'pg-org-logbook-prepend-item) logbook)))


#+end_src

The logbook functions are tested in Listing [[t/logbook]].

#+name: t/logbook
#+begin_src emacs-lisp :tangle no :noweb yes :wrap src text
  <<src/logbook>>

  (ert-deftest pg-org/logbook ()
    (let* ((item-1-str "I *1*")
           (item-2-str "I 2")

           (strings (list item-1-str item-2-str))
           (paragraphs (-map #'org-ml-build-paragraph! strings))
           (items (-map #'org-ml-build-item paragraphs))

           (item-3-str "I =3=")
           (item-3-sec-str (org-ml-build-secondary-string! item-3-str))
           (item-3-paragraph (org-ml-build-paragraph! item-3-str))
           (item-3-item (org-ml-build-item item-3-paragraph))

           (expected-logbook (pg-org-ml-build
                              `(drawer
                                "LOGBOOK"
                                (plain-list
                                 (item (paragraph! ,item-1-str))
                                 (item (paragraph! ,item-2-str))))))

           (expected-logbook-prepended (pg-org-ml-build
                                        `(drawer
                                          "LOGBOOK"
                                          (plain-list
                                           (item (paragraph! ,item-3-str))
                                           (item (paragraph! ,item-1-str))
                                           (item (paragraph! ,item-2-str)))))))

      ;; Builders
      (should (equal (org-ml-build-drawer "LOGBOOK") (pg-org-logbook)))
      (should (equal expected-logbook
                     (pg-org-logbook-from-strings strings)))
      (should (equal expected-logbook
                     (pg-org-logbook-from-items items)))
      (should (equal expected-logbook
                     (pg-org-logbook-from-paragraphs paragraphs)))

      ;; Accessors
      (should (equal strings
                     (pg-org-logbook-get-strings expected-logbook)))
      (should (equal items
                     (pg-org-logbook-get-items expected-logbook)))
      (should (equal paragraphs
                     (pg-org-logbook-get-paragraphs expected-logbook)))

      ;; Mutators
      (should (equal expected-logbook-prepended
                     (pg-org-logbook-prepend-string
                      item-3-str
                      expected-logbook)))

      (should (equal expected-logbook-prepended
                     (pg-org-logbook-prepend-paragraph
                      item-3-paragraph
                      expected-logbook)))

      (should (equal expected-logbook-prepended
                     (pg-org-logbook-prepend-item
                      item-3-item
                      expected-logbook)))

      (should (equal expected-logbook-prepended
                     (pg-org-logbook-prepend-secondary-string
                      item-3-sec-str
                      expected-logbook)))))


  (pg-ert-run-tests-string "pg-org/logbook")
#+end_src

*** Logbook Entries on the Headline


Org-ML provides two ways to get logbook items from a headline. The official way is via =org-ml-headline-get-logbook-items=, which takes the user's logging configuration into account. A proxy for this function that doesn't burden the caller with supplying configuration information is in Listing [[src/logging-configuration]].

It is also straightforward to get logbook entries using the =org-ml-match= interface. The =pg-org-headline-logbook-entries= function in Listing [[src/headline-logbook-entries]] uses this method to return a headline's logbook entries. Despite not requiring the configuration info plist, it honors the =:log-into-drawer= value set in =pg-org-headline-logging-config=.

The other major change in this function is that it returns the =paragraph= element associated with each logbook item, not the =item= element. This is often more convenient when the user merely wants to read the logbook. The functions defined in Listing [[src/headline-logbook-entries]] are more suitable to general-purpose use of the logbook, including manipulation or synthesis of lists of logbook items.

#+name: src/headline-logbook-entries
#+begin_src emacs-lisp
  (defun pg-org-headline-logbook-entries (headline)
    "Given a headline org element, return its logbook entries as a
  list of paragraph elements. If the headline doesn't contain any
  logbook entries, return `nil'."
    (let ((drawer-name (plist-get
                        pg-org-headline-logging-config
                        :log-into-drawer)))
      (->> headline
           (org-ml-match
            '(section
              (:and drawer (:drawer-name drawer-name))
              plain-list
              item
              paragraph)))))
#+end_src

The =pg-org-headline-logbook-entries= function is tested using the sample Org input in Listing [[input/logbook-simple]]. Listing [[t/headline-logbook-entries]] shows how the function can be used to rapidly consume the entries in the logbook.

#+name: input/logbook-simple
#+caption: Org document used in testing =pg-org-headline-logbook entries=
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :END:
    :LOGBOOK:
    - Top entry
    - Middle entry
    - Very first entry
    :END:
#+end_src

#+name: t/headline-logbook-entries
#+begin_src emacs-lisp :noweb eval :tangle no  :wrap src text
  <<src/headline-logbook-entries>>
  (require 's)

  (pg-org-deftest pg-org/headline-logbook-entries input/logbook-simple
    (let* ((entries (->> doc
                         (org-ml-match '(headline))
                         (car)
                         (pg-org-headline-logbook-entries)))
           (entry-strings (-map #'org-ml-to-trimmed-string entries)))
      (should (s-equals-p (nth 0 entry-strings) "Top entry"))
      (should (s-equals-p (nth 1 entry-strings) "Middle entry"))
      (should (s-equals-p (nth 2 entry-strings) "Very first entry"))

      (should (eq (nth 0 (nth 0 entries)) 'paragraph))
      (should (eq (nth 0 (nth 1 entries)) 'paragraph))
      (should (eq (nth 0 (nth 2 entries)) 'paragraph))))

  (pg-ert-run-tests-string "pg-org/headline-logbook-entries")

#+end_src

*** Logbook Entry Types

**** Status changes

When configured to do so, Org will log changes between to-do keywords into the logbook. These logbook entries have a specific text format, but to Org it's still a single secondary string. This code parses that string and recovers the juicy data inside.

#+name: src/rx-logbook-status-changed
#+begin_src emacs-lisp
  (defcustom pg-org--rx-logbook-status-change
    (rx "State"
        (+ whitespace)
        "\"" (group (+ (not "\""))) "\""
        (+ whitespace)
        "from"
        (+ whitespace)
        "\"" (group (+ (not "\""))) "\"")
    "Regex matching log entries of to-do state transitions, per the
    default state format string in
    `org-log-note-headings'. Capturing accomplishments will break
    if that entry in `org-log-note-headings' is changed. (As will
    large chunks of org-agenda.) In that case, it will be necessary
    to customize this regex to correspond."
    :type 'regexp
    :group 'pg-org)
#+end_src

A previous version of this function lived in =pm.org= and took =item= elements instead of =paragraph= elements. This function works better with the output of the new and improved =pg-org-headline-logbook-entries=, however.

#+name: src/paragraph-parse-status-change
#+begin_src emacs-lisp
  (defun pg-org-paragraph-parse-status-change (para)
    "If PARA is a logbook entry that looks like it was generated
    when a to-do item's status changed, parse it and return a list of
    the state it was changed to (as a string), the state it was
    changed from (as a string), the timestamp, and an org paragraph
    element representing any additional notes provided by the
    user. Otherwise, return nil."
    (-when-let* [((_ _ s ts . the-rest)  para)
                 ;; parse out the to and from states
                 ((_ from to) (->> (org-ml-to-trimmed-string s)
                                   (s-match pg-org--rx-logbook-status-change)))
                 ;; if notes exist, create as new paragraph
                 (notes (->> (if (org-ml-is-type 'line-break (first the-rest))
                                 ;; trick to inline (cdr the-rest) as args
                                 (let ((para-objs (-map (lambda (x) `(quote ,x)) (cdr the-rest))))
                                   (eval `(org-ml-build-paragraph ,@para-objs)))
                               ;; no additional notes == empty paragraph
                               (org-ml-build-paragraph))
                             (org-ml-remove-parents)))]
      (list to from (org-ml-remove-parents ts) notes)))
#+end_src

The =pg-org-paragraph-parse-status-change= function is tested in Listing [[t/paragraph-parse-status-change]], using input from Listing [[input/logbook-status-changes]].


#+name: input/logbook-status-changes
#+caption: Sample used for testing
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :END:
    :LOGBOOK:
    - State "DOING"      from "BLOCKED"    [2021-12-11 Sat 20:06] \\
      Back on the case
    - State "BLOCKED"    from "DOING"      [2021-12-11 Sat 20:05] \\
      Waiting on parts from the supplier
    - State "DOING"      from "TODO"       [2021-12-11 Sat 20:04] \\
      In process, it's harder than it looks
    - Not a status update
    :END:
#+end_src

Note that =pg-org-paragraph-parse-status-change= returns =nil= if the parse fails, so the spurious additional item in the input is ignored.

(TODO: I think this test is broken? Look at it more later.)

#+name: t/paragraph-parse-status-change
#+begin_src emacs-lisp :noweb eval :tangle no  :wrap src text
  <<src/paragraph-parse-status-change>>
  (require 'ts)

  (pg-org-deftest pg-org/paragraph-parse-status-change
      input/logbook-status-changes
    (let ((entries (->> doc
                        (org-ml-match '(headline))
                        (car)
                        (pg-org-headline-logbook-entries)
                        (-keep #'pg-org-paragraph-parse-status-change))))
      (pg-ert-shouldmap
          entries
          '(("BLOCKED" "DOING" "[2021-12-11 Sat 20:06]"
             "Back on the case")
            ("DOING" "BLOCKED" "[2021-12-11 Sat 20:05]"
             "Waiting on parts from the supplier")
            ("TODO" "DOING" "[2021-12-11 Sat 20:046]"
             "In process, it's harder than it looks"))
        (-let (((act-to act-from act-ts act-notes) act)
               ((exp-to exp-from exp-ts exp-notes) exp))
          (equal act-to exp-to)
          (equal act-from exp-from)
          (ts=  (ts-parse-org-element act-ts) (ts-parse-org exp-ts))
          (string-equal (org-ml-to-trimmed-string act-notes) exp-notes)))))

  (pg-ert-run-tests-string "pg-org/paragraph-parse-status-change")

#+end_src


*** Lookahead matching

The =org-ml-match= function is very powerful, including a generalized =:pred= function that can match on a user-supplied predicate. Match predicates take a single argument representing the node currently being evaluated, and return =t= if the node should match, for whatever definition the predicate uses.

One limitation of =org-ml-match= predicates is a lack of a "lookahead" capability: There's no natural way to select a node based on the properties of the nodes it contains. One /can/ build predicates that, themselves, call =org-ml-match= on a node to find matching child nodes, but this is inconvenient for ad-hoc matching.

The following is a way around that limitation. =pg-org-match-lookahead= takes a set of =org-ml-match= criteria /\kappa/ and returns a predicate that applies those criteria to the node under consideration–meaning, it's a predicate that asserts that there exists one or more child nodes beneath the current node that match /\kappa/.

#+name: ex/lookahead/1
#+begin_src org :results none :exports code :tangle no
  ,* Foo
  ,** Tasks
  ,* Bar
  ,** Tasks
  ,* Baz
  ,** Tasks
  ,* Additional notes
#+end_src

For example, consider the task of matching only the  headlines in Listing [[ex/lookahead/1]] that contain subheadings for tasks. As can be seen in Listing [[ex/lookahead/1.1]] the match criteria =(headline (:and headline (:raw-value "Tasks")))= will match the subheads, but not the tasks. (It is sometimes possible to backtrack to an ancestor from a child node, but not always and not reliably.)

#+name: ex/lookahead/1.1
#+begin_src emacs-lisp :results code :exports code :tangle no
  (pg-org-with-src-doc ex/lookahead/1
    (->> doc
         (org-ml-match '(headline (:and headline (:raw-value "Tasks"))))
         (-map #'org-ml-remove-parents)))
#+end_src

Using a lookahead predicate, however, it is possible to get the result we want, as in Listing [[ex/lookahead/1.2]].

#+name: ex/lookahead/1.2
#+begin_src emacs-lisp :results code :exports code :tangle no
  (defun my-task-predicate (node)
    (org-ml-match '((:and headline (:raw-value "Tasks"))) node))

  (pg-org-with-src-doc ex/lookahead/1
    (->> doc
         (org-ml-match '((:and headline (:pred my-task-predicate))))
         (-map #'org-ml-remove-parents)))
#+end_src

The tradeoff here is obviously recursion, but the maximum recursion should be the maximum depth of the document tree, absent chicanery in the predicate like searching on a node's parent.

**** General-purpose lookahead
<<sct-gp-lookahead>>

Listing [[src/lookahead]] shows a generalized function for returning a lookahead-style match predicate. It's a simple partial application of =org-ml-match=.

#+name: src/lookahead
#+begin_src emacs-lisp
  (defun pg-org-lookahead (match-criteria)
    "Return a function that takes an org-element node and runs
    `org-ml-match' on it using MATCH-CRITERIA as the match
    criteria. Returns a true value if the match returns results,
    else `nil'."
    (-partial #'org-ml-match match-criteria))
#+end_src

This function is not as useful as we might wish, because the value of =:pred= must be a symbol, not an actual function. So the code in Listing [[ex/lookahead/2.1]], for example doesn't work.

#+name: ex/lookahead/2.1
#+begin_src emacs-lisp :results code :exports code :tangle no
  ;; This doesn't work....
  (pg-org-with-src-doc ex/lookahead/1
      (->> doc
           (org-ml-match `((:and headline
                                 (:pred ,(pg-org-lookahead
                                          '(:and headline (:raw-value "Tasks")))))))
           (-map #'org-ml-remove-parents)))
#+end_src


It can, however, be used somewhat awkwardly with =cl-letf=, as shown by the test in Listing [[t/lookahead]].


#+name: t/lookahead
#+begin_src emacs-lisp :exports code  :noweb eval :tangle no  :wrap src text
  <<src/lookahead>>


  (pg-org-deftest pg-org/lookahead
      ex/lookahead/1
    (cl-letf* (((symbol-function 'has-tasks)
                (lambda (el)
                  (pg-org-lookahead
                   '((:and headline (:raw-value "Tasks"))))))
               (results (org-ml-match '((:and headline (:pred has-tasks))) doc)))
      (pg-ert-shouldmap results '("Foo" "Bar" "Baz")
        (string-equal (org-ml-get-property :raw-value act) exp))))

  (pg-ert-run-tests-string "pg-org/lookahead")
#+end_src

This construct adds considerably to the complexity of an =org-match= call, but enables a powerful way of searching and selecting nodes in a document. The =pg-org-match= function presents this power while hiding ythe complexity.

**** =pg-org-match=

Using the =cl-letf= trick described in Section [[sct-gp-lookahead]], we can write a macro that extends =org-ml-match= with some new functionality.

First, we can implement a =:lookahead= selector that takes match criteria and applies it to the node using =pg-org-lookahead= using the =cl-letf= trick. That  will simplify the =org-ml-match= call in Listing [[test-lookahead]]
to the code in Listing [[ex/match/lookahead]].

#+name: ex/match/lookahead
#+begin_src emacs-lisp :exports code :tangle no
  (pg-org-match '((:and headline
                        (:lookahead
                         ((:and headline
                                (:raw-value "Tasks"))))))
                node)
#+end_src

We can also extend the match syntax in a very powerful way, with /anaphoric predicates/. This would permit a user to specify a predicate as arbitrary code in the match criterion itself. Consider, for instance, a selector for all timestamps after a certain time. Currently, candidate =timestamp= elements would be selected with =org-ml-match=, then filtered. With an anaphoric predicate, this could be declared in a single match structure, as in Listing [[ex/match/anaphoric-pred/1]].

#+name: ex/match/anaphoric-pred/1
#+begin_src emacs-lisp :exports code :tangle no
  ;; Only timestamps from the last 7 days
  (pg-org-match '((:and timestamp
                        (:-pred ((ts> (ts-parse-org-element el)
                                      (ts-adjust 'day -7 (ts-now)))))))
                node)
#+end_src

Some of this logic could still be encapsulated in a function, as shown in Listing [[ex/match/anaphoric-pred/2]]. This increases readability and code reuse, as functions like =timestamp-within-last= could be used in many places.

#+name: ex/match/anaphoric-pred/2
#+begin_src emacs-lisp :exports code :tangle no
  ;; Only timestamps from the last 7 days
  (defun timestamp-within-last (num unit el)
    (ts> (ts-parse-org-element el)
         (ts-adjust unit num (ts-now))))

  (pg-org-match '((:and timestamp (:-pred (timestamp-within-last 7 'day el))))
                node)
#+end_src

This would translate to the code in Listing [[ex/match/anaphoric-pred/3]].

#+name: ex/match/anaphoric-pred/3
#+begin_src emacs-lisp :exports code :tangle no
  ;; Only timestamps from the last 7 days
  (defun timestamp-within-last (num unit el)
    (ts> (ts-parse-org-element el)
         (ts-adjust unit num (ts-now))))

  (cl-letf* (((symbol-function 'a-predicate)
              (lambda (el)
                (timestamp-within-last 7 'day el))))
    (pg-org-match '((:and timestamp (:pred a-predicate))) node))
#+end_src

***** =pg-org--match-build-pattern=

The main work of the =pg-org-match= macro is done in =pg-org--match-build-pattern=, which recursively traverses a match pattern, making some transformations as necessary to add our new functionality. The code for this function is in [[src/-match-build-pattern]].

The input to =pg-org--match-build-pattern= is an =org-ml-match= pattern, augmented with the extensions implemented in =pg-org-match=. The output is a double =(clauses pattern)=, which =pattern= is the original pattern transformed as necessary to enable our additional functionality, and =clauses= is a set of =(symbol function)= pairs. Using =cl-letf= and the =org-ml-match= =:pred= functionality, we can implement =:lookahead= and =:-pred= using only these additional functions and transformations.

One thing to note in =pg-org-match-build-pattern= is that =:lookahead= is implemented with =pg-org-match= itself, allowing the user to implement lookahead matches with =:-pred= and (though the utility seems questionable) =:lookahead=.

#+name: src/-match-build-pattern
#+begin_src emacs-lisp
  (defun pg-org--match-build-pattern (pattern)
    ;; Make this (-let (...) (case ...)) into a (pcase ...)?
    (-let (((tok . rest) pattern))
      (cl-case tok
        ;; The patterns we transform:
        ;; - :lookahead
        (:lookahead
         (progn
           (-let* ((sym (gensym "lookahead-"))
                   (clause
                    `((symbol-function (quote ,sym))
                      (lambda (el) (pg-org-match (quote ,(car rest)) el))))
                   (new-pattern `(:pred ,sym)))
             (list (list clause) new-pattern))))
        ;; - :-pred
        (:-pred
         (progn
           (-let* ((sym (gensym "pred-"))
                   (clause
                    `((symbol-function (quote ,sym))
                      (lambda (el) ,(car rest))))
                   (new-pattern `(:pred ,sym)))
             (list (list clause) new-pattern))))
        ;; unary prefixes; leave them unchanged and consume rest of the list
        ((:first :last :and :or :not)
         (progn
           (-let (((clauses rest-pattern) (pg-org--match-build-pattern rest)))
             (list clauses (cons tok rest-pattern)))))
        ;; 2-ary prefixes
        (:nth
         (progn
           (-let* (((x . rest) rest)
                   ((clauses rest-pattern) (pg-org--match-build-pattern rest)))
             (list clauses (-concat `(,tok ,x) rest-pattern)))))
        ;; 3-ary prefixes
        (:sub
         (progn
           (-let* (((x y . rest) rest)
                   ((clauses rest-pattern) (pg-org--match-build-pattern rest)))
             (list clauses (-concat `(,tok ,x ,y) rest-pattern)))))
        ;; general case – if it's a list, modify it and consume the rest
        ;; of the list. If it's a symbol we don't need to modify, yield
        ;; it unchanged and consume the rest of the list.
        (t
         (cond
          ((listp tok)
           ;; Subpattern; get the clauses and new pattern associated
           ;; with it, and combine with the rest of the "horizontal"
           ;; pattern
           (progn
             (cond
              ;; base case
              ((eq nil tok)
               '(nil nil))
              ;; descend into list
              (t
               (-let* (((cl1 p1) (pg-org--match-build-pattern tok))
                       ((cl2 p2) (pg-org--match-build-pattern rest))
                       (new-clauses (-concat cl1 cl2))
                       (new-pattern (cons p1 p2)))
                 (list new-clauses new-pattern))))))

          ((symbolp tok)
           (cond
            ;; Property name (or any other special form org-ml-match
            ;; handles)
            ((s-starts-with? ":" (symbol-name tok))
             (progn
               (message "[symbol] TOK: %s" tok)
               (message "[symbol] REST: %s" rest)
               (list nil `(,tok ,@rest))))
            ;; Element name
            (t
             (progn
               (-let (((clauses pattern) (pg-org--match-build-pattern rest)))
                 (list clauses (cons tok pattern)))))))))
        )))
#+end_src


****** Testing

The =pg-org--match-build-pattern= function makes a lot of decisions. Listing [[t/-match-build-pattern/1]] shows a unit test for basic functionality, demonstrating that the function can traverse the match structure non-destructively in the cases where it is just proxying =org-ml-match=.

#+name: t/-match-build-pattern/1
#+begin_src emacs-lisp :noweb yes :exports code :tangle no  :wrap src text
  <<src/-match-build-pattern>>

  (ert-deftest pg-org/-match-build-pattern/1 ()
    (cl-macrolet ((-? (test-form expected-value)
                      `(should (equal (pg-org--match-build-pattern ,test-form)
                                      ,expected-value))))
      (-? '()
          '(nil nil))

      ;; In case you're wondering, org-ml-match does this too
      (should-error (pg-org--match-build-pattern 'headline))

      (-? '(headline)
          '(nil (headline)))

      (-? '(:nth 2 headline)
          '(nil (:nth 2 headline)))

      (-? '(:sub 1 2 headline)
          '(nil (:sub 1 2 headline)))

      (-? '(:drawer-name "LOGBOOK")
          '(nil (:drawer-name "LOGBOOK")))

      (-? '(headline section paragraph)
          '(nil (headline section paragraph)))

      (-? '(:and (:nth 2 section) headline)
          '(nil (:and (:nth 2 section) headline)))

      (-? '(:and (:sub 1 2 section) headline)
          '(nil (:and (:sub 1 2 section) headline)))

      (-? '(:and headline (:drawer-name "LOGBOOK"))
          '(nil (:and headline (:drawer-name "LOGBOOK"))))))

  (pg-ert-run-tests-string "pg-org/-match-build-pattern/1")
#+end_src

Testing our added functionality is more challenging, as it introduces code containing unique symbols created with =gensym=. We can still make assertions about the structure of the output, however, as shown in [[t/-match-build-pattern/2]] and [[t/-match-build-pattern/3]].

#+name: t/-match-build-pattern/2
#+caption: Testing lookahead functionality in =pg-org--match-built-pattern=
#+begin_src emacs-lisp :noweb yes :exports code :tangle no  :wrap src text
  <<src/-match-build-pattern>>

  (ert-deftest pg-org/-match-build-pattern/2 ()
    (let ((output (pg-org--match-build-pattern '((:lookahead (headline))))))
      (let* ((sym (eval (cadr (caaar output))))
             (fn  (cadaar output))
             (expected-fn '(lambda (el) (pg-org-match '(headline) el)))
             (expected `((((symbol-function (quote ,sym)) ,expected-fn)) ((:pred ,sym)))))
        (should (symbolp sym)) ;; sym is quoted, so one more unboxing
        (should (functionp fn))
        (should (equal fn expected-fn))
        (should (equal output expected)))))

  (pg-ert-run-tests-string "pg-org/-match-build-pattern/2")
#+end_src

#+name: t/-match-build-pattern/3
#+caption: Testing anaphoric predicate functionality in =pg-org--match-built-pattern=
#+begin_src emacs-lisp :noweb yes :exports code :tangle no  :wrap src text
  <<src/-match-build-pattern>>

  (ert-deftest pg-org/-match-build-pattern/3 ()
    (let ((output (pg-org--match-build-pattern '((:-pred (equal (foo el) 1))))))
      (let* ((sym (cadr (caaar output)))
             (fn  (cadaar output))
             (expected-fn '(lambda (el) (equal (foo el) 1)))
             (expected `((((symbol-function ,sym) ,expected-fn)) ((:pred ,sym)))))
        (should (symbolp sym))
        (should (functionp fn))
        (should (equal fn expected-fn))
        (should (equal output expected)))))

  (pg-ert-run-tests-string "pg-org/-match-build-pattern/3")
#+end_src



***** =pg-org-match=

Listing [[src/match]] shows the very simple =pg-org-match= function. Clearly, all the heavy lifting is done in =pg-org--match-build-pattern=. This is the public entry point, however, so the function is well-documented.

#+name: src/match
#+begin_src emacs-lisp
    (defmacro pg-org-match (pattern node)
      "Match PATTERN against NODE, in the form of `org-ml-match', but with a more powerful extended syntax.

    `pg-org-match' supports the following additional match patterns:
  ()
    `(:lookahead SUBPATTERN)' runs a second `org-ml-match' on the
    children of the current node, returning a true value if
    SUBPATTERN matches any of the node's children. In other words, it
    matches nodes based on the properties of the nodes' children. In
    this way, one can, say, match headlines with a LOGBOOK drawer
    with the following pattern:

      (:and headline
            (:lookahead (section (:and drawer
                                       (:drawer-name \"LOGBOOK\")))))

    `(:-pred CODE)' implements an anaphoric predicate. CODE is
    interpreted as the body of a lambda expression, which is called
    on a node using `(:pred ...)'. CODE may refer to the variable
    `el', which is the element currently being considered. Thus, the
    following code block:

      (cl-letf ((fn (lambda (el)
                       (org-ml-headline-has-tag \"work\" el))))
        (org-ml-match '((:pred fn)) node))


    Is equivalent to this call to `pg-org-match':

      (pg-org-match '((:-pred (org-ml-headline-has-tag \"work\" el))) node)

    In all other respects, this function is equivalent to a call to
    `org-ml-match'.
    "
      (-let (((clauses new-pattern) (pg-org--match-build-pattern pattern)))
        `(cl-letf ,clauses
           (org-ml-match ,new-pattern ,node))))
#+end_src




****** Testing

In Listing [[t/match/1]], we do one last white-box test of the macro to ensure that it generates the kind of code we expect.

#+name: t/match/1
#+caption: Testing pg-org-match
#+begin_src emacs-lisp :noweb yes :exports code :tangle no  :wrap src text
  <<src/-match-build-pattern>>
  <<src/match>>

  (ert-deftest pg-org/match/1 ()
    (let*  ((output (macroexpand-1
                     '(pg-org-match
                       ((:-pred (org-ml-headline-has-tag "work" el))) node)))
            (sym (cadr (caaadr output)))
            (expected `(cl-letf
                           (((symbol-function ,sym) (lambda (el)
                                    (org-ml-headline-has-tag "work" el))))
                         (org-ml-match ((:pred ,sym)) node))))
      (should (symbolp sym))
      (should (equal output expected))))

  (pg-ert-run-tests-string "pg-org/match/1")

#+end_src

But will it blend? Let's find out. Our input for these tests is in Listing [[input-pg-org-match/t]].

#+name: input/match
#+caption: Sample used for testing
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :END:
    :LOGBOOK:
    - State "DOING"      from "BLOCKED"    [2021-12-11 Sat 20:06] \\
      Back on the case
    - State "BLOCKED"    from "DOING"      [2021-12-11 Sat 20:05] \\
      Waiting on parts from the supplier
    - State "DOING"      from "TODO"       [2021-12-11 Sat 20:04] \\
      In process, it's harder than it looks
    - Not a status update
    :END:

  ,* TODO Something else to do
    :PROPERTIES:
    :ASSIGNEE: Johnny Unitas
    :END:
#+end_src

The code in Listing [[t/match/2]] demonstrates the usage of =pg-org-match= with the =:lookahead= matcher. The match is done at the headline level, but only the headline for "Rewire the security system" is selected because it contains a logbook.

#+name: t/match/2
#+caption: A test showing how the :lookahead matcher works.
#+begin_src emacs-lisp :noweb yes :exports code :tangle no  :wrap src text
  <<src/-match-build-pattern>>
  <<src/match>>

  (pg-org-deftest pg-org/match/2
      input/match
    (let ((results (pg-org-match
                    '((:and headline
                            (:lookahead
                             (section
                              (:and drawer
                                    (:drawer-name "LOGBOOK"))))))
                    (org-ml-remove-parents doc)
                    )))
      (should (= (length results) 1))
      (let ((result (car results)))
        (should (equal (org-ml-get-type result) 'headline))
        (should (equal (org-ml-get-property :raw-value result)
                       "Rewire the security system")))))

  (pg-ert-run-tests-string "pg-org/match/2")
#+end_src

The code in Listing [[t/match/3]] exercises the =:-pred= matcher to search for a headline using a regular expression. The possibilities for =:-pred= are vast; =(:lookahead)= is simple to implement as =(:-pred (pg-org-match pattern el))=, for instance.

#+name: t/match/3
#+begin_src emacs-lisp :noweb yes :exports code :tangle no :wrap src text
  <<src/-match-build-pattern>>
  <<src/match>>
  (require 's)

  (pg-org-deftest pg-org/match/2
      input/match
    (let ((results
           (pg-org-match '((:and headline
                                 (:-pred
                                  (s-matches-p
                                   "else"
                                   (org-ml-get-property :raw-value el)))))
                         (org-ml-remove-parents doc))))
      (should (= (length results) 1))
      (let ((result (car results)))
        (should (equal (org-ml-get-type result) 'headline))
        (should (equal (org-ml-get-property :raw-value result)
                       "Something else to do")))))

  (pg-ert-run-tests-string "pg-org/match/2")
#+end_src



* Provide

#+BEGIN_SRC emacs-lisp
  (provide 'pg-org)
  ;;; pg-org.el ends here
#+END_SRC
