#+TITLE: autovenv: Automatically find Python Virtual Environments
#+STARTUP: indent
* Introduction

This began as a fork of [[https://github.com/marcwebbie/auto-virtualenv][auto-virtualenv.el]] by Markwebbie. That version doesn't appear to be actively maintained, and contains a hard dependency on [[https://github.com/bbatsov/projectile][Projectile]], an excellent package that I nevertheless don't need, and which doesn't need to be installed for this code to work.

I have made some substantial changes to that library, mostly removing functionality and focusing solely on automatically changing the virtual environment. Most of the removed functionality can be better achieved with simple customizations, or by using other Emacs capabilities/packages.

The main effect of these changes is that the library does one thing as well as possible, leaving plenty of opportunities for the user to decide when it's done and what other things might be done in coordination.

** Installation

I recommend installing this via =use-package=:

#+begin_src emacs-lisp :tangle no
  (use-package autovenv
    :ensure t
    :hook ((find-file-hook
            eshell-directory-change-hook) . autovenv-find-and-activate))
#+end_src

One can add other hooks as necessary, even ~projectile-switch-project-hook~ if you use Projectile. (Emacs's builtin Project library seems to lack an analogous hook, sadly.)


* Package Header

#+begin_src emacs-lisp
  ;;; autovenv.el --- Automatically activate Python virtualenvs based on project directory -*- lexical-binding: t; -*-

  ;; Copyright (C) 2025 Phil Groce

  ;; Author: pgroce <pgroce@gmail.com>
  ;; Version: 0.1.17
  ;; Keywords: python, virtualenv, environment, tools, projects
  ;; Package-Requires: ((cl-lib "0.5"))
  ;; License: GPL-3.0-or-later

#+end_src

* Commentary

#+begin_src emacs-lisp

  ;;; Commentary:
  ;;
  ;;
  ;; autovenv aims to automatically manage the use of Python virtual
  ;; environments in Emacs by always making sure the "right" virtual
  ;; environment is active for the curent buffer.
  ;;
  ;; autovenv only tends to the core configuration of the Emacs
  ;; environment to support virtual environments: Setting the
  ;; VIRTUAL_ENV environment variable, and adding the relevant bin
  ;; directory to exec-path and the PATH environment
  ;; variable. Furthermore, its algorithm for locating virtual
  ;; environments is very simple. As a result, it has no dependencies
  ;; that don't ship with Emacs.
  ;;
  ;; That said, the user can override the location process to use a
  ;; different scheme if desired, and hooks around activation and
  ;; deactivation permit maintenance of additional state if needed, such
  ;; as reloading LSPs, so autovenv can serve as the core of a workflow
  ;; that encompasses many other tools, such as Projectile or LSP Mode.
  ;;
  ;; This is a fork of auto-virtualenv.el
  ;; <https://github.com/marcwebbie/auto-virtualenv> by Markwebbie. Most
  ;; of it has been rewritten, but some of the original code survives,
  ;; and the template has been very helpful.
  ;;
  ;; To use this package, add the `autoenv-find-and-activate' function
  ;; to hooks associated with changes to virtual
  ;; environments. `find-file-hook', for instance, is a good candidate,
  ;; as are hooks for shell buffers that are run when the
  ;; default-directory changes. If desired, customize the hooks in the
  ;; `autovenv' Customize group to execute custom behavior on activation
  ;; or deactivation, or override the location of a virtual environment
  ;; with a custom fuction.
  ;;
  ;; The following use-package declaration illustrates one of the
  ;; simplest configurations:
  ;;
  ;;   (use-package autovenv
  ;;     :ensure t
  ;;     :hook ((find-file-hook
  ;;             eshell-directory-change-hook) . autovenv-find-and-activate))
  ;;
  ;;
  ;;; Code:

  (require 'cl-lib)
#+end_src

* Custom variables

#+begin_src emacs-lisp
  (defgroup autovenv nil
    "Automatically activate Python virtual environments."
    :group 'python)

  (defcustom autovenv-verbose nil
    "Enable verbose output for debugging."
    :type 'boolean
    :group 'autovenv)

  (defcustom autovenv-pre-activate-hook nil
    "Hook run just beore a Python virtualenv is activated"
    :type 'hook
    :group 'autovenv)

  (defcustom autovenv-post-activate-hook nil
    "Hook run just after a Python virtualenv is activated"
    :type 'hook
    :group 'autovenv)

  (defcustom autovenv-pre-deactivate-hook nil
    "Hook run just before a Python virtualenv is deactivated"
    :type 'hook
    :group 'autovenv)

  (defcustom autovenv-postdeactivate-hook nil
    "Hook run just after a Python virtualenv is deactivated"
    :type 'hook
    :group 'autovenv)
#+end_src

* Code


#+begin_src emacs-lisp

  (defun autovenv--message (msg)
    (when autovenv-verbose
      (message "autovenv: %s" msg)))

  ;;
  ;; Activation/Deactivation (That is, getting/setting the venv)
  ;;

  ;;;; Activation/deactivation really consists of
  ;;;;   - Setting the VIRTUAL_ENV environment variable
  ;;;;
  ;;;;   - Updating the PATH environment variable to include the venv's
  ;;;;     /bin directory
  ;;;;
  ;;;;   - Updating exec-path to include venv's /bin directory
  ;;;;
  ;;;; Deactivation obviously involves reverting all those changes:
  ;;;; Removing a directory from PATH and exec-path, and unsetting
  ;;;; VIRTUAL_ENV.
  ;;;;
  ;;;; These functions are solely concerned with manipulating the state
  ;;;; Python and Emacs need to utilize a venv; any other state autovenv
  ;;;; maintains to know when to activate/deactivate is not the problem
  ;;;; of these functions. Similarly, lifecycle management (e.g.,
  ;;;; calling (deactivate) before calling (activate) when changing
  ;;;; between venvs) is not in scope


  (defvar autovenv--venv nil
    "Currently set virtual environment path.")

  (defvar autovenv--python-version nil
    "Currently set Python version.")

  (defun autovenv--activate (venv pyver)
    "Activate the virtual environment at NEW-VENV, with the python version at
  PYVER."
    (autovenv--message (format "Activating %s" venv))
    (run-hooks 'autovenv-pre-activate-hook)

    (let* ((venv-bin (file-name-as-directory
                      (file-name-concat venv "bin"))))
      (setq autovenv--venv venv
            autovenv--python-version pyver)
      (setq exec-path (cons venv-bin exec-path))
      (setenv "VIRTUAL_ENV" venv)
      (setenv "PATH" (concat venv-bin path-separator (getenv "PATH"))))
    (run-hooks 'autovenv-post-activate-hook))

  (defun autovenv--deactivate ()
    "Deactivate any active virtual environment."
    ;; Grab the venv prior to running pre-deactivate-hook. It's bad form
    ;; to mess with that in the hook, but it's not impossible
    (let* ((venv (getenv "VIRTUAL_ENV"))
           (venv-bin (file-name-as-directory
                      (file-name-concat venv "bin"))))
      (autovenv--message (format "Deactivating %s" venv))
      (run-hooks 'autovenv-pre-deactivate-hook)
      (setq exec-path (delete venv-bin exec-path))
      ;; Split, splice, and rejoin PATH without external dependencies
      (setenv "PATH" (mapconcat
                      'identity
                      (delete venv-bin
                              (split-string (getenv "PATH") path-separator))
                      path-separator))
      (setq exec-path (delete venv-bin exec-path))
      (setenv "VIRTUAL_ENV" nil)
      (run-hooks 'autovenv-post-deactivate-hook)))



  ;;
  ;; Locating the appropriate virtualenv
  ;;
  ;; Locating the virtual environment involves determining the project
  ;; root, then identifying an associated virtualenv, if one exists.
  ;;


  ;;;; Root locating functions

  (defun autovenv-local-locator ()
    "Default locator funtion. Looks for a .venv directory in the default
  directory of the current buffer. If one is not found, returns the .venv
  directory in the nearest parent directory. If neither the current
  directory nor any of its parents contain a .venv directory, the function
  fails and nil is returned."
  (when-let* ((dir (locate-dominating-file default-directory ".venv")))
      (file-name-as-directory
       (file-name-concat (expand-file-name dir) ".venv"))))

  ;;;; TODO: Write a global locator that reads project files to identify
  ;; named virtualenvs and find them in well-known locations, then make
  ;; the default locator a combinator of the local and global
  ;; locator. This will require poring through uv, poetry, etc. docs to
  ;; determine what their behavior is and how to emulate it. The local
  ;; locator provides good value for now though, and if a user wants to
  ;; do this work they can.

  (defcustom autovenv-virtualenv-locator #'autovenv-local-locator
    "Function used to locate a virtual environment. Takes no arguments and
  returns the path to a virtual environment directory, or nil if no
  virtual environment can be found."
    :type 'function
    :group 'autovenv)

  (defvar autovenv-virtualenv-path nil
    "If the value of this variable is not nil, it should be a path to a
  Python virtual environment. autovenv will use this value
  unconditionally, bypassing any other attempts to locate a
  virtualenv.

  Though this variable can be set globally, it is principally intended for
  use as a buffer- or directory-local variable, allowing users to define
  arbitrary virtualenvs for use in specific files or projects.")

  (defun autovenv--locate-venv ()
    "Find the virtualenv directory, if any, for the current buffer.

  If `autovenv-virtualenv-path' is non-nil, it will be used unconditionally. This
  variable can be set globally, but is probably best used as a buffer- or
  directory-local variable.

  If `autovenv-virtualenv-path' is nil, the function defined in
  `autovenv-virtualenv-locator' will be used to find a suitable virtualenv for
  this buffer. By default, this variable is set to use
  `autovenv-default-locator'.

  If neither `autovenv-virtualenv-path' nor `autovenv-virtualenv-locator' are set, or if
  `autovenv-virtualenv-locator' cannot locate a suitable virtual environment, this
  function will return nil, indicating no suitable virtual environment is
  present."
    (cond
     ((stringp autovenv-virtualenv-path)
      autovenv-virtualenv-path)
     ((and (functionp autovenv-virtualenv-locator))
      (funcall autovenv-virtualenv-locator))
     (t nil)))


  ;;;;;; Python version location
  (defun autovenv-read-python-version (version-file)
    "Read a Python version file."
    (when (file-readable-p version-file)
      (let* ((version-str
              (string-trim (with-temp-buffer
                             (insert-file-contents version-file)
                             (buffer-string)))))
        (if (string-equal "" version-str)
            nil
          version-str))))
  (defvar autovenv-python-version nil
    "If the value of this variable is not nil, it will be used as the Python
  version for Autovenv. This variable should be suitable for use with
  Pyenv, and with Emacs Pyenv mode.

  This variable can be set globally, or as a directory- or buffer-local
  variable. If unset, Autovenv will try to find the Python version
  dynamically.")

  (defun autovenv-pyenv-locator ()
    "Attempt to determine the desired version of Python to use for the
  current buffer using (more or less) the Pyenv heuristics:

  1. Try to find a .python-version file and use its contents

  2. Try to find a version file in the directory pointed to by the
  PYENV_HOME environment variable, if that variable is set, and use that.

  3. Try to find a .pyenv/version file in the user's home directory and
  use that"
    (if-let* ((dir (locate-dominating-file
                    default-directory ".python-version")))
        (autovenv-read-python-version
         (file-name-concat (expand-file-name dir) ".python-version"))
      (if-let* ((dir (getenv "PYENV_HOME")))
          (autovenv-read-python-version
           (file-name-concat (expand-file-name dir) "version"))
        (let* ((homedir (getenv "HOME"))
               (dir (file-name-concat
                     (expand-file-name homedir) ".pyenv")))
          (autovenv-read-python-version
           (file-name-concat dir "version"))))))

  (defcustom autovenv-python-version-locator #'autovenv-pyenv-locator
    "Function used to locate a Python version. Takes no arguments and
  returns the Python version to use, or nil if no suitable Python version
  can be identified."
    :type 'function
    :group 'autovenv)


  (defun autovenv--locate-python-version ()
    "Locate a suitable Python version for the current buffer.

  If `autovenv-python-version' is non-nil, it will be used as the Python
  version. This variable can be set globally, or as a buffer- or
  directory-local variable.

  If `autovenv-python-version' is nil, use the function defined in
  `autovenv-python-version-locator' to identify a Python version.

  If neither of these are set, or if `autovenv-python-version' cannot find
  a Python version, this Unction will return nil, indicating a Python
  version couldn't be found.'"
    (cond
     ((stringp autovenv-python-version)
      autovenv-python-version)
     ((and (functionp autovenv-python-version-locator))
      (funcall autovenv-python-version-locator))
     (t nil)))




  ;;
  ;; Storing and comparing virtualenv state to determine if changes
  ;; should be made.
  ;;
  ;; The state for a given buffer (i.e., the "info") is a list (dir
  ;; venv), where venv is a path to a virtualenv, and dir is the
  ;; default-directory associated with the buffer at the time the venv
  ;; was determined.
  ;;

  (defvar-local autovenv--info nil
    "Contains working info about what the appropriate Python virtualenv
  should be for this buffer. Nil, or else a triple of the form (DIR VENV-DIR
  PY-VERSION).")

  (defun autovenv--correct-venv ()
    "Return what the \"correct\" venv should be for this buffer, updating
  cached information as appropriate. Sets and returns the value of
  `autovenv--info'."
    (let ((old autovenv--info))
      (setq autovenv--info
            (if (and (not (equal old nil))
                     (equal (car old) default-directory))
                old
              ;; Ensure the output of the locator is formatted as a
              ;; directory (with the trailing slash), since the user may
              ;; be inconsistent
              (let* ((version-located (autovenv--locate-python-version))
                     (venv-located (autovenv--locate-venv))
                     ;; file-name-as-directory can't handle nils so....
                     (venv-dir (if (eq nil venv-located)
                                   nil
                                 (file-name-as-directory venv-located))))
                `(,default-directory ,venv-dir ,version-located))))))


  (defmacro autovenv-current-venv ()
    "Return the currently configured venv. Syntax sugar over (getenv
  \"VIRTUAL_ENV\")"
    '(getenv "VIRTUAL_ENV"))


  ;;
  ;; Getting the virtual environment
  ;;

  (defun autovenv-get-venv ()
    "Return the name of the currently set virtual environment, or nil if
  unset."
    (interactive)
    autovenv--venv)

  (defun autovenv-get-python-version ()
    "Return the currently set Python version, or nil if unset."
    (interactive)
    autovenv--python-version)

  ;;
  ;; Entry points -- determine state and activate/deactivate as necessary
  ;;


  (defun autovenv-find-and-activate ()
    "If a Python virtual environment should be active for the
  default-directory of the current buffer, activate it. If not (and one is
  activated already), deactivate it.

  This function can be used as a hook to automatically activate a virtual
  environment when relevant events occur, such as a directory change. To
  refresh the virtualenv information when a buffer (more precisely, a
  window) is selected, see `autovenv-window-selection-function'."
    (interactive)

    ;; Step 1: Find out what the venv should be
    ;; Step 2: Find out what the current venv is
    (let* ((info (autovenv--correct-venv))
           (new-venv (nth 1 info))
           (new-pyver (nth 2 info))
           (old-venv (autovenv-get-venv)))
      ;; Step 3: If they're different, change it
      (when (not (eq new-venv old-venv))
        (if (eq new-venv nil)
            (autovenv--deactivate)
          (progn
            ;; Always deactivate the old venv before activating the new
            ;; one, to ensure that things like path variables get
            ;; cleaned up.
            (autovenv--deactivate)
            (autovenv--activate new-venv new-pyver))))))



  (defun autovenv-window-function (frame-or-window)
    "Function to find and activate an appropriate Python virtual environment
  from the `window-buffer-change-functions' and
  `window-selection-change-functions' hooks."
    ;; According to the docstring of window-selection-change-functions,
    ;; frame-or-window is only a window when the function is
    ;; buffer-local; otherwise, it's a frame. I can't imagine the use
    ;; case for this, and I can't imagine why this function would be
    ;; used buffer-locally, but we'll be maximally conservative for now.
    (let* ((buff (cond
                  ((framep frame-or-window)
                   (car (frame-parameter frame-or-window 'buffer-list)))
                  ((windowp frame-or-window)
                   (window-buffer frame-or-window)))))
      (with-current-buffer buff
        (autovenv-find-and-activate))))
#+end_src

* Provides

#+begin_src emacs-lisp
  (provide 'autovenv)

  ;;; autovenv.el ends here
#+end_src

* Basement

#+begin_src emacs-lisp :tangle no

  (defcustom autovenv-global-dirs
    '("~/.virtualenvs/" "~/.pyenv/versions/" "~/.envs/" "~/.conda/" "~/.conda/envs/")
    "List of global directories to search for virtual environments by project name."
    :type '(repeat string)
    :group 'autovenv)

  (defcustom autovenv-local-dirs
    '(".venv" "venv")
    "List of local directories to search for virtual environments."
    :type '(repeat string)
    :group 'autovenv)

  (defcustom autovenv-python-project-files
    '("requirements.txt" "Pipfile" "pyproject.toml" "setup.py" "manage.py" "tox.ini"
      ".flake8" "pytest.ini" ".pre-commit-config.yaml" "environment.yml"
      "__init__.py" "*.py" ".python-version")
    "List of files that identify a Python project."
    :type '(repeat string)
    :group 'autovenv)




  (defun autovenv--debug (msg &rest args)
    "Print MSG formatted with ARGS if `autovenv-verbose' is enabled."
    (when autovenv-verbose
      (message (apply 'format (concat "[autovenv] " msg) args))))

  (defun autovenv-read-python-version (project-root)
    "Read the virtual environment name from .python-version file in PROJECT-ROOT, if present."
    (let ((version-file (expand-file-name ".python-version" project-root)))
      (when (file-readable-p version-file)
        (autovenv--debug "Virtualenv selected from .python-version file at %s" version-file)
        (string-trim (with-temp-buffer
                       (insert-file-contents version-file)
                       (buffer-string))))))

  (defun autovenv-find-global-venv (env-name)
    "Search for ENV-NAME in `autovenv-global-dirs`, only at top level of each directory."
    (autovenv--debug "Searching for %s in global directories" env-name)
    (cl-some (lambda (dir)
               (let ((venv-path (expand-file-name env-name dir)))
                 (when (file-directory-p venv-path)
                   (autovenv--debug "Found global virtualenv in %s" venv-path)
                   venv-path)))
             autovenv-global-dirs))

  (defun autovenv-is-python-project (project-root)
    "Check if PROJECT-ROOT contains Python project files."
    (autovenv--debug "Checking if %s has Python project files" project-root)
    (or (cl-some (lambda (file)
                   (file-expand-wildcards (expand-file-name file project-root)))
                 autovenv-python-project-files)
        (directory-files-recursively project-root "\\.py$" 2)))
#+end_src
