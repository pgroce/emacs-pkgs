#+STYLE: <link rel="stylesheet" type="text/css" href="style.css">
#+STARTUP: indent
#+TITLE: pg-util: Utility functions

These functions have general utility, and I use them in many of my other modules.

Some of them probably belong in their own modules....

Many of these functions come from [[mwd5i@mwd5i.org][Michael Duggan]]. Thanks, Duggan.

* Package Header

#+BEGIN_SRC emacs-lisp
  ;;; pg-util.el --- Utility functions

  ;; Copyright (C) 2017 Phil Groce

  ;; Author: Phil Groce <pgroce@gmail.com>
  ;; Version: 0.2
  ;; Package-Requires: ((dash "2.13.0"))
  ;; Keywords: utility
#+END_SRC




* Requires

#+BEGIN_SRC emacs-lisp
  (require 'cl)
  (require 'dash)
#+END_SRC

* Code


*** Debugging
I stole this from the =dbg= macro in [[http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html][this Clojure macro tutorial]], and from the =spy= method of the [[http://clojure.github.io/clojure-contrib/branch-master/logging-api.html][Clojure logging API]].

The following function will =(message)= out a lisp form and its value, then return the value. The form is evaluated only once, so if the form has side-effects, they won't change when run in the debugging.

This makes for a very powerful debugging tool. Just replace, say, =(foo x)= with =(pg/spy (foo x))= and you get the form and value printed out.

#+BEGIN_SRC emacs-lisp
  ;;;###autoload
  (defmacro pg/spy (x)
    "Print the form and value of x to the message buffer, then
  return x. x is only evaluated once."
    (let ((pg/x (make-symbol "x")))
      `(let ((,pg/x ,x)) (message (format "%s = %s" ',x  ,pg/x)) ,pg/x)))
#+END_SRC
*** List manipulation


#+begin_src emacs-lisp
  ;;;###autoload
  (defun pg-util-zip (lists)
    "Return list of lists where each element of index n of the
  output list is a list of all elements of index n of the input
  lists. For instance: (pg-util-zip '(1 2 3) '(4 5 6) '(7 8 9)) -> '((1
  4 7) (2 5 8) (3 6 9))"
    (apply #'mapcar* #'list lists))

  ;;;###autoload
  (defun pg-util-list-add-unique (l1 l2)
    "Return a new list composed of the values in L1 and the values
    in L2 that don't already exist in L1. (IOW, L1 + L2, with no
    duplications from L2.)

    If there are duplicate values in L1, these will be preserved."
    (-concat l1 (--filter (not (memq it l1)) l2)))

  ;;;###autoload
  (defun pg-util-list-add-unique-var (var values)
    "Update the list in VAR with the new values in VALUES using
    `pg-util-list-add-unique'."
    (set var (pg-util-list-add-unique (symbol-value var) values)))

  ;;;###autoload
  ;;;###autoload
  (defun pg-util-alist-update (a1 a2)
    "Return a new alist with the elements in A1, updated by A2. If
  an element key exists in A1 and A2, it is updated in-place with
  the value from A2. Elements in A2 with keys that are not in A1
  are appended to the end of the new alist."
    (let ((a2-only (--filter (eq nil (assoc (car it) a1)) a2))
          (updated-a1 (--map (or (assoc (car it) a2) it) a1)))
      (-concat updated-a1 a2-only)))

  ;;;###autoload
  (defun pg-util-alist-update-var (var values)
    "Update the alist in VAR with the new values in VALUES using
  `pg-util-alist-update'. Shorthand for `(set
  var (pg-util-alist-update (symbol-value-var) values)'."
    (set var (pg-util-alist-update (symbol-value var) values)))


  ;;;###autoload
  (defun pg-util-alist-keys (in-alist)
    "Return a list of the keys in IN-ALIST, an associative list."
    (if (null in-alist)
        nil
      (cons (caar in-alist) (pg-util-alist-keys (cdr in-alist)))))


  ;;;###autoload
  (defun pg-util-plist-keys (in-plist)
    "Return a list of the keys in IN-PLIST, a property list."
    (if (null in-plist)
        nil
      (cons (car in-plist) (pg-util-plist-keys (cddr in-plist)))))


  ;;; Note that hash-table-keys and hash-table-values live in subr-x
#+end_src

=auto-mode-alist= is a little special, in that its keys are strings, so the standard alist functions (which use =eq=) don't work on it. This usually doesn't bother anyone because they just use =(add-to-list ...)= and don't worry about the potential multiple entries for one file extension. But it worries me, dammit. It's least confusing when there's only one entry per extension.

This function manipulates =auto-mode-alist=-like lists to my satisfaction.

#+BEGIN_SRC emacs-lisp
  ;;;###autoload
  (defun pg-util-update-auto-mode-alist (ext new-mode &optional amalist)
    "Return a new copy of AMALIST (if nil, use `auto-mode-alist')
  in which the mode function for EXT is replaced with NEW-MODE."

    (let* ((amalist (if amalist amalist auto-mode-alist))
           (filtered-amalist (--filter (not (equal ext (car it)))
                                          amalist)))
      (add-to-list 'filtered-amalist `(,ext . ,new-mode))))
#+END_SRC

*** Am I in a minor mode?

There may be an easier way to detect if the current buffer features a particular minor mode, but I haven't found it yet.

#+BEGIN_SRC emacs-lisp
  ;;;###autoload
  (defun pg-util-minor-mode-active-p (minor-mode)
    "Return t if the minor mode is active in the current buffer,
  otherwise nil."
    (condition-case nil
        (and (symbolp minor-mode) (symbol-value minor-mode))
      ('error nil)))
#+END_SRC

*** Clear out the kill ring
If you accidentally put sensitive material in the kill ring, you have various options, depending on the sensitivity of the data. It often isn't appropriate to just clear the kill ring and move on; it's unlikely that the memory will be overwritten before it's =free='d, for instance.

If your only concern is that end-users don't see the information in the history, though, this function is useful. It clears the kill ring, the "Select and Paste" menu, and the record of keys you can view with =view-lossage=.

#+BEGIN_SRC emacs-lisp
  ;;;###autoload
  (defun pg-util-nuke-kill-ring ()
    "Try to annihilate all history of anything recently typed,
  copied or pasted."
    (setq kill-ring nil)
    (setcdr yank-menu nil)
    (clear-this-command-keys)
    ;; Things get ugly with various histories, but try a little
    (setq minibuffer-history '()))
#+END_SRC

*** "Diminishing" major modes

=[[http://marmalade-repo.org/packages/diminish][diminish]]= modifies how minor modes display their names on the modeline. It's a depencency of =use-package=, so if you're using that, you get =diminish= for free!

=diminish= only works on minor modes, though. "Diminishing" major modes is simple enough, but this macro simplifies it further.

#+BEGIN_SRC emacs-lisp
  ;;;###autoload
  (defmacro pg-util-diminish-major (mode new-name)
        "Simulate the effects of diminish on major modes."
        `(add-hook
          (quote,(intern (format "%s-hook" (symbol-name mode))))
          (lambda () (setq mode-name ,new-name))))
#+END_SRC




* Provide

#+BEGIN_SRC emacs-lisp
  (provide 'pg-util)
  ;;; pg-util.el ends here
#+END_SRC
