#+STYLE: <link rel="stylesheet" type="text/css" href="style.css">
#+startup: indent entitiespretty
#+TITLE: pm-task.org: Tasks

This library extends Org mode's to-do items with more robust tools for external reporting, especially on multiuser tasks. Org already supports the following:

- Task status
- Event logging via the logbook, including automation-assist for logging status changes
- Deadlines
- A reasonably powerful query engine geared for use with the Org agenda

The main extensions this library provides are:

- Additional metadata, such as assignee
- A different query engine geared toward collecting status information for reporting

Acquiring tasks is not the responsbility of this library; tasks are just headlines with to-do keywords, Org has several ways to acquire those. It will provide some tools for filtering lists of tasks once they're acquired.

* Project Management Versus Task Tracking
:PROPERTIES:
:CUSTOM_ID: sct-pm-vs-todo
:END:

Org implements a to-do tracker for an individual; this package implements tasks for project management, possibly among many users. With different goals come differences in nomenclature. Moreover, Org defines most of the elements of its to-do system syntactically, although some semantics are implied in the support tools Org implements, like clocks or the Org agenda. Put another way, Org gives you keywords and tags and logbook entries. Org mostly avoids defining what that means.

By contrast, this package specifically imposes a semantic framework on these structures, drawn from that of project management and "issue tracking" tools such as Bugzilla and Jira. This model consists of the following elements:

- /Tasks/ (sometimes /issues/) reflect finite-time, finite-effort units of work. Tasks may be typed.
- The work in tasks may be done by many people. (Or, rarely, other entities like automated processes or teams.) One person is primarily responsible for getting the work done at a given time; that person is said to be /assigned/ the task.
- A task has a lifecycle; it transitions between different /states/ or /statuses/ before a final disposition. Other events of interest may also occur in that time. (Those events' semantics often less well-defined, and may degenerate all the way back to a syntactic definition "Freeform text associated with a timestamp.")
- Tasks usually have a textual /description/. The description is associated with the event of task creation, though it may be modified afterward.
- While these are the core features of task trackers oriented toward project management, most associate additional metadata, such as related tasks or associated files. Allowable metadata may be defined by task type or status. (For instance, an issue that has been resolved may carry metadata about how it was resolved.)

That said, this package is focused only on the construction of a rich task construct, which can be used in many ways by a project manager. To that end, every extension this package offers is optional; the most minimal task is a headline with a to-do item. In particular, this system should be easy to overlay onto preexisting Org files that have not been designed with this system in mind and still provide some value.

* Future Work
:PROPERTIES:
:CUSTOM_ID: sct-future-work
:END:

** Comments and Temporal Event Logging

- Necessity
  - For comments: Not so much
    - Bigger deal when multiple users get involved
  - For other things: Somewhat more important
    - Already ways to timestamp things in Org
    - But: Having it in one place would have advantages when searching

*** Event logging: Possible approaches

**** Store events in Logbook

Approach: Use the "notes" type of logbook entry as an event log

Pros:
- Keeps everything in the logbook
  - Simplifies searching/sorting
- Less extension of Org functionality

Cons:
- Have to deal with unrelated notes
- No less complexity, just pushing it into the notes entry where there's less structural support (i.e., the "port 80" problem)
- Limited expressiveness
  - Full Org syntax up to and including blocks (e.g., =begin_src=), but no headlines


**** Store events in custom drawer

Pros:
- Full control of that drawer
- Somewhat centralized
- Somewhat contained

Cons:
- More than about 2 drawers on a headline are awkward and unreadable

*** Comments: Possible approaches

**** Items in event log drawer

Some pointers here: The =org-add-note= and =org-add-log-setup= functions. (Note that you can't add new note types, but may want to borrow the technique.)

Pros:
- Contained
- Natural representation if you think of comments as rich event log entries
- Metadata consolidated with content

Cons:
- Limited expressiveness (see above)
- Harder to read


**** Headlines

Pros:
- Very easy to read
- Very expressive

Cons:
- Imposes some structure on the body of the headline
  - Unfortunate precedent
  - May not be fully backward-compatible
- Creates linkage problem
  - Unversioned metadata (e.g., "creator") can be stored with comment
  - Versioned metadata (e.g., "comment edited") should be stored as log entry
  - Requires thinking about key relationships (org-id?)


#+name: ex/task/3
#+caption: A fully elaborated task
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :CUSTOM_ID: task-12345
    :END:
    :LOGBOOK:
    - Note taken on [2021-12-10 Fri 09:06] \\
      Comment [[task-12345-comment-9875]] edited by "Tobin Rote"
    - State "DOING"      from "BLOCKED"    [2021-12-11 Sat 20:36] \\
      Back on the case
    - State "BLOCKED"    from "DOING"      [2021-12-11 Sat 20:25] \\
      Waiting on parts from the supplier
    - State "DOING"      from "TODO"       [2021-12-11 Sat 20:14] \\
      In process, it's harder than it looks
    - Note taken on [2021-12-10 Fri 08:06] \\
      Task created
    :END:
    :CHANGES:
    - [2021-12-10 Fri 09:10] \\

    - [2021-12-10 Fri 08:04] \\
      Assignment changed to "Bart Starr" from ""
    :END:

  ,** Comments

  ,*** Bart jst won Super Bowl I
      :PROPERTIES:
      :CUSTOM_ID: comment-9876
      :CREATED:  [2021-12-10 Fri 09:10]
      :CREATOR: Vince Lombardi
      :END:

      He'll be back in the office in a few weeks.

  ,*** What's the status?
      :PROPERTIES:
      :CUSTOM_ID: comment-9875
      :CREATED:  [2021-12-10 Fri 09:05]
      :CREATOR: Tobin Rote
      :END:

      A customer asked about the security system. Just checking....

  ,*** Microphone check
      :PROPERTIES:
      :CUSTOM_ID: comment-9874
      :CREATED:  [2021-12-10 Fri 09:00]
      :CREATOR: Bart Starr
      :END:
      :CHANGES:
      -
      :END:
      1, 2, what is this?
#+end_src


* Code



** Package Header
#+name: src/header
#+BEGIN_SRC emacs-lisp :noweb-ref src
  ;;; pm-task.el --- Task handling for project management

  ;; Copyright (C) 2021 Phil Groce

  ;; Author: Phil Groce <pgroce@gmail.com>
  ;; Version: 0.1.2.3
  ;; Package-Requires: ((emacs "26.1") (dash "2.19") (s "1.12") (org-ml "5.7") (ts "0.3") (pg-ert "0.1") (pg-org "0.1"))
  ;; Keywords: productivity
#+END_SRC



** Requires

#+name: src/requires
#+begin_src emacs-lisp :results silent :noweb-ref src
  (require 'dash)
  (require 's)
  (require 'ts)
  (require 'org-ml)
  (require 'pg-ert)
  (require 'pg-org)
#+end_src


** Tasks

The simplest possible task is contained in Listing [[ex/task/1]].

#+name: ex/task/1
#+caption: A more complicated task
#+begin_src org
  ,* DOING Rewire the security system
#+end_src

As mentioned in [[#sct-pm-vs-todo]], a Task is just an Org to-do item, and the most minimal to-do item is, syntactically, a Task. Where possible, =pm-task= keeps the syntax and semantics of existing Org to-do mechanism like the to-do tags themselves, the =LOGBOOK= drawer, etc. A few additional semantic elements are also defined, built on existing Org primitives as much as possible.

Listing [[ex/task/2]] shows a simple Org file containing a single task. This task also contains a logbook with several entries. One feature shown here that is not common to Org to-do items is an /Assignee/. This doesn't make much sense for Org's single-user task tracking, but the Tasks defined here are for managing projects with multiple contributors. The parts of a Task shown here are listed below; the description of a Task uses Org's structural terminology, refer to the Org manual, particularly the manual for the =org-element= package, if terms are unfamiliar.

- The /status/, shown as the to-do keyword. Here, that status corresponds directly to the most recent logbook entry, meaning the Task is /synchronized/. This package can work with Tasks that are not synchronized, but not with full functionality.
- The task /title/ is the title of the headline.
- The logbook entries tracking changes to the to-do keyword are referred to here as /status changes/.

#+name: ex/task/2
#+caption: A more complicated task
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :END:
    :LOGBOOK:
    - State "DOING"      from "BLOCKED"    [2021-12-11 Sat 20:06] \\
      Back on the case
    - State "BLOCKED"    from "DOING"      [2021-12-11 Sat 20:05] \\
      Waiting on parts from the supplier
    - State "DOING"      from "TODO"       [2021-12-11 Sat 20:04] \\
      In process, it's harder than it looks
    :END:

    This is a good place to describe the issue. You can currently put anything you like here.

  ,** Subheadings

     You can also include subheadings and [[https://google.com/][links]] and anything else that makes sense.
#+end_src

Everything in Listing [[ex/task/2]] is standard Org syntax used in ways that Org expects. Extensions to this model have their own semantics, but are still constructed from Org primitives. A task exhibiting all the features =pm-task= supports is contained Listing [[ex/task/3]]. It demonstrates the following additional features:

- An /assignee/, a user who is responsible for finishing the task
- A number of /comments/
- Unique IDs for the task and for each comment.
- Additional logbook entries tracking event creation and comment editing

Comments and the non-status events in the logbook are currently aspirational, see [[#sct-future-work]].

** Creating and Updating Tasks

The code in Listing [[src/builders]] creates new tasks. One can, of course, create tasks by hand, or treat existing Org headlines as, tasks, but these functions produce tasks with all the optional features, notably timestamps for events such as creation and reassignment.

#+name: src/builders
#+begin_src emacs-lisp :results silent :noweb-ref src
  (defun pm-task-build (the-headline keyword description assignee user)
    (let* ((now-ts  (ts-now))
           (now-str (ts-format "[%Y-%m-%d %a %H:%M]" now-ts))
           (now-org `(timestamp 'inactive
                                ,(ts-year now-ts)
                                ,(ts-month now-ts)
                                ,(ts-day now-ts)
                                ,(ts-year now-ts)
                                ,(ts-month now-ts)
                                ,(ts-day now-ts)
                                :hour-start ,(ts-hour now-ts)
                                :minute-start ,(ts-minute now-ts)
                                :hour-end ,(ts-hour now-ts)
                                :minute-end ,(ts-minute now-ts)))
           (user (or user (user-login-name)))
           ;; no default for assignee; if it's nil, don't include it
           (the-headline (or the-headline ""))
           (keyword (or keyword "TODO"))
           (description (or description ""))
           (assignee (or assignee "")))
      `(headline
        :title (secondary-string! ,the-headline)
        :todo-keyword ,keyword
        (section
         (property-drawer
          ;; Interestingly, org-element stores node properties as strings,
          ;; including org-mode timestamps. But in a buffer, they're
          ;; handled as regular timestamps. ¯\_(ツ)_/¯
          (node-property "CREATED" ,now-str)
          (node-property "CREATOR" ,user)
          (node-property "ASSIGNEE" ,assignee))
         (drawer
          "LOGBOOK"
          :post-blank 1
          (plain-list
           (item (paragraph
                  ,(format "Task created by \"%s\" on %s" user now-str)))))
         (paragraph! ,description)))))
#+end_src

The

#+begin_src emacs-lisp :noweb yes :tangle no :wrap src org
  <<src/builders>>
  (->> (pm-task-build "FooBar" "TODO" "Foo the bar!" "harry bovik" "frank gorshin")
       (pg-org-ml-build)
       (org-ml-to-trimmed-string))
#+end_src

#+RESULTS:
#+begin_src org
,* TODO FooBar
:PROPERTIES:
:CREATED:  [2022-01-16 Sun 11:56]
:CREATOR:  frank gorshin
:ASSIGNEE: harry bovik
:END:
:LOGBOOK:
- Task created by "frank gorshin" on [2022-01-16 Sun 11:56]
:END:

Foo the bar!
#+end_src



** Accessing tasks

The code in Listing [[src/accessors]] extracts information from tasks represented as Org element trees.

#+name: src/accessors
#+begin_src emacs-lisp :noweb-ref src
  (defun pm-task-status-changes (task)
    "Returns all status change logbook entries for TASK as a list
    of records `(from to when notes)', where `from' and `to' are
    the original and changed statuses, `when' is the org-element
    representation of the timestamp, and `notes' is an Org
    secondary string containing any associated notes."
    (->> (pg-org-headline-logbook-entries task)
         (-keep #'pg-org-paragraph-parse-status-change)))

  (defun pm-task-status-last-change (task)
    "Returns the most recent status change logbook entry for
    TASK. For the format of this record see
    `pm-task-status-changes'"
    (nth 0 (pm-task-status-changes task)))

  (defun pm-task-status-last-change-from (task)
    "Returns the status changed from in the most recent logbook
  entry for TASK."
    (nth 0 (pm-task-status-last-change task)))

  (defun pm-task-status-last-change-to (task)
    "Returns the status changed to in the most recent logbook entry
  for TASK."
    (nth 1 (pm-task-status-last-change task)))

  (defun pm-task-status-last-change-timestamp (task)
    "Returns the timestamp in the most recent logbook entry for
  TASK, as a ts.el timestamp object."
    (->> (nth 2 (pm-task-status-last-change task))
         (ts-parse-org-element)))

  (defun pm-task-status-last-change-org-timestamp (task)
    "Returns the timestamp in the most recent logbook entry for
  TASK, as an org-element."
    (nth 2 (pm-task-status-last-change task)))

  (defun pm-task-status-last-change-notes (task)
    "Returns the notes in the most recent logbook entry for
  TASK."
    (nth 3 (pm-task-status-last-change task)))

  ;; I'm making a Big Assumption that entries in the logbook will
  ;; already be sorted by time.

  (defun pm-task-current-status (task)
    "Returns the current status of TASK. The current status is the
    todo keyword of the headline; if the headline has no todo
    keyword, it is `nil'.

  This may not be synchronized with the most recent logbook entry;
  if the user wants this, they must call ()`pm-task-is-synced'
  first."
    (org-ml-get-property :todo-keyword task))

  (defun pm-task-assignee (task)
    "Returns the user to whom the task is assigned. Returns `nil'
    if there is no assignee."
    (or (org-ml-headline-get-node-property "assignee" task)
        (org-ml-headline-get-node-property "ASSIGNEE" task)))


  (defun pm-task-created-on (task)
    "Returns the time of this tasks creation, as a ts
    structure. Returns `nil' if TASK has no \"CREATED\" or
    \"created\" property drawer, or if the contents of that
    property are not a valid org-mode timestamp."
    (when-let* ((created (or (org-ml-headline-get-node-property "created" task)
                             (org-ml-headline-get-node-property "CREATED" task)))
                (created-ts (ts-parse-org created)))
      created-ts))

  (defun pm-task-creator (task)
    "Returns the creator of this task, or `nil' if none is specified."
    (or (org-ml-headline-get-node-property "CREATOR" task)
        (org-ml-headline-get-node-property "creator" task)))


#+end_src

*** Testing

A set of tests demonstrates their usage. The input for these tests is in Listing [[ex/test/basic-test]].

#+name: input/basic
#+caption: Sample used for testing
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :CREATED:  [2021-12-01 Wed 10:00]
    :CREATOR: Vince Lombardi
    :END:
    :LOGBOOK:
    - State "DOING"      from "BLOCKED"    [2021-12-11 Sat 20:36] \\
      Back on the case
    - State "BLOCKED"    from "DOING"      [2021-12-11 Sat 20:25] \\
      Waiting on parts from the supplier
    - State "DOING"      from "TODO"       [2021-12-11 Sat 20:14] \\
      In process, it's harder than it looks
    :END:

  ,* DONE Get past the guard
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2021-12-31 Fri 17:48] \\
      Got past 'em, easy peasy
    :END:
#+end_src

**** =pm-task-status-last-change=

 #+name: t/status-last-change
#+begin_src emacs-lisp :noweb eval :tangle no  :wrap src text
   <<src>>

   (pg-org-deftest pm-task/status-last-change
       input/basic
     (-let (((from to timestamp notes)
             (->> (org-ml-match '(headline) doc)
                  (nth 0)
                  (pm-task-status-last-change))))
       (should (string-equal to "DOING"))
       (should (string-equal from "BLOCKED"))
       (should (ts= (ts-parse-org-element timestamp) (ts-parse-org "[2021-12-11 Sat 20:36]")))
       (should (string-equal (org-ml-to-trimmed-string notes) "Back on the case"))))

   (pg-org-deftest pm-task/status-last-change-to
       input/basic
     (let ((to (->> (org-ml-match '(headline) doc)
                    (nth 0)
                    (pm-task-status-last-change-to))))
       (should (string-equal to "DOING"))))

   (pg-org-deftest pm-task/status-last-change-from
       input/basic
     (let ((to (->> (org-ml-match '(headline) doc)
                    (nth 0)
                    (pm-task-status-last-change-from))))
       (should (string-equal to "BLOCKED"))))


   (pg-org-deftest pm-task/status-last-change-timestamp
       input/basic
     (let ((timestamp (->> (org-ml-match '(headline) doc)
                           (nth 0)
                           (pm-task-status-last-change-timestamp))))
       (should (ts= timestamp (ts-parse-org "[2021-12-11 Sat 20:36]")))))

   (pg-org-deftest pm-task/status-last-change-org-timestamp
       input/basic
     (let ((timestamp (->> (org-ml-match '(headline) doc)
                           (nth 0)
                           (pm-task-status-last-change-org-timestamp))))
       (should (ts= (ts-parse-org-element timestamp) (ts-parse-org "[2021-12-11 Sat 20:36]")))))


   (pg-org-deftest pm-task/status-last-change-notes
       input/basic
     (let ((notes (->> (org-ml-match '(headline) doc)
                       (nth 0)
                       (pm-task-status-last-change-notes))))
       (should (string-equal (org-ml-to-trimmed-string notes) "Back on the case"))))

   (pg-ert-run-tests-string "pm-task/status-last-change")

#+end_src

**** =pm-task-current-status=

This test uses an additional input, shown in Listing [[input/current-status]]. (Technically, a bare headline is not a task, but a core design principle of this library is to be liberal in what is accepted.)

#+name: input/current-status
#+begin_src org
  ,* No status here
#+end_src

#+name: t/current-status
#+begin_src emacs-lisp :noweb eval :tangle no  :wrap src text
  <<src/accessors>>
  (pg-org-deftest pm-task/current-status/1
      input/basic
    (let ((status (->> (org-ml-match '(headline) doc)
                       (nth 0)
                       (pm-task-current-status))))
      (should (string-equal status "DOING"))))

  (pg-org-deftest pm-task/current-status/2
      input/current-status
    (let ((task (->> (org-ml-match '(headline) doc)
                     (nth 0))))
      (should (eq nil (pm-task-current-status task)))))

  (pg-ert-run-tests-string "pm-task/current-status")
#+end_src

**** =pm-task-assignee=

#+name: t/assignee
#+begin_src emacs-lisp :noweb eval :wrap src text
  <<src/accessors>>

  (pg-org-deftest  pm-task/assignee
      input/basic
    (let ((assignee (->> (org-ml-match '(headline) doc)
                         (nth 0)
                         (pm-task-assignee))))
      (should (string-equal assignee "Bart Starr"))))

  (pg-ert-run-tests-string "pm-task/assignee")
#+end_src



**** =pm-task-created-on=

#+name: t/created-on
#+begin_src emacs-lisp :noweb eval :wrap src text
  <<src/accessors>>

  (pg-org-deftest  pm-task/created-on
      input/basic
    (let ((created (->> (org-ml-match '(headline) doc)
                        (nth 0)
                        (pm-task-created-on))))
      (should (ts= created (ts-parse-org "[2021-12-01 Wed 10:00]")))))

  (pg-ert-run-tests-string "pm-task/created-on")
#+end_src

**** =pm-task-creator=

#+name: t/creator
#+begin_src emacs-lisp :noweb eval :wrap src text
  <<src/accessors>>

  (pg-org-deftest  pm-task/creator
      input/basic
    (let ((creator (->> (org-ml-match '(headline) doc)
                        (nth 0)
                        (pm-task-creator))))
      (should (string-equal creator "Vince Lombardi"))))

  (pg-ert-run-tests-string "pm-task/creator")
#+end_src



** Selecting and parsing tasks

Because a Task is an Org headline, it is easy to parse using Org's =org-element= library or Org-ML, as shown in Listing [[ex/parsing-a-headline]].

#+name: ex/parsing-a-headline
#+caption: Parsing a headline with =org-ml=
#+begin_src emacs-lisp :noweb eval :tangle no :exports code :results code :wrap src emacs-lisp
  (pg-org-with-src-doc ex/task/2
    (->> doc
         (org-ml-match '(headline))
         (first)
         (org-ml-remove-parents)))
#+end_src

Using =org-ml= and =pg-org=, we can search through the headlines for items of interest and, where necessary, verify preconditions. To simplify the process further, this package defines these operations as a series of ypredicates in terms of tasks. These predicates permit the user to select tasks directly based on their task-related semantics, such as resolution times or assigned users.

*** Predicates

This is a work in progress. As predicates are defined to satisfy use cases in [[#sct-use-cases]], they will be added here.

#+name: src/predicates
#+begin_src emacs-lisp :noweb-ref src
  ;; Everything has to deal with unsynced tasks. It's the caller's
  ;; responsibility to check if the task is synced before using.


  (defun pm-task-is-synced (task)
    "Return `t' if TASK has a to-do item that matches the current
    state from the last entry in the logbook. If not, the logbook
    can't be used to determine the time of the most recent status
    change or the previous status."
    (let ((todo (org-ml-get-property :todo-keyword task)))
      (and todo
           (equal todo (pm-task-status-last-change-to task)))))

  ;; Time comparison

  (defun pm-task-status-changed-on (timestamp task)
    "Return `t' if last logbook entry for TASK is equal to
  TIMESTAMP, a ts object. If TASK is not synced, results are
  undefined."
    (ts=  timestamp (pm-task-status-last-change-timestamp task)))

  (defun pm-task-status-changed-after (timestamp task)
    "Return `t' if last logbook entry for TASK occured after
  TIMESTAMP, a ts object. If TASK is not synced, results are
  undefined."
    (ts< timestamp (pm-task-status-last-change-timestamp task)))

  (defun pm-task-status-changed-on-or-after (timestamp task)
    "Return `t' if last logbook entry for TASK occured after
  TIMESTAMP (a ts object) and task is synced. If TASK is not
  synced, results are undefined."
    (ts<=  timestamp (pm-task-status-last-change-timestamp task)))

  (defun pm-task-status-changed-before (timestamp task)
    "Return `t' if last logbook entry for TASK occured before
  TIMESTAMP (a ts object) and task is synced. If TASK is not
  synced, results are undefined."
    (ts> timestamp (pm-task-status-last-change-timestamp task)))

  (defun pm-task-status-changed-on-or-before (timestamp task)
    "Return `t' if last logbook entry for TASK occured before
  TIMESTAMP and task is synced. If TASK is not synced, results are
  undefined."
    (ts>= timestamp (pm-task-status-last-change-timestamp task)))

  ;; Status comparison

  (defun pm-task-status-in (status-or-statuses task)
    "Return `t' if the current status of TASK is one of the strings
    in STATUS-OR-STATUSES, which can be a single string or list of
    strings. if STATUS-OR-STATUSES is `nil' (or a list where one of
    its elements is nil), this function will return nil."
    (cond
     ((eq status-or-statuses nil)
      (eq nil (pm-task-current-status task)))
     ((stringp status-or-statuses)
      (s-equals-p status-or-statuses (pm-task-current-status task)))
     ((listp status-or-statuses)
      (--some (pm-task-status-in it task) status-or-statuses))
     (t (error "status-or-statuses must a string or list of strings"))))

  ;; Assignee

  (defun pm-task-is-assigned-to (user-or-users task)
    "Return `t' if the assignee of TASK is in USER-OR-USERS, which
  can be a single string or a list of strings. If USER-OR-USERS is
  `nil' (or a list where one of its elements is nil), this function
  will return `t' if TASK is unassigned."
    (cond
     ((eq user-or-users nil)
      (eq nil (pm-task-assignee task)))
     ((stringp user-or-users)
      (s-equals-p user-or-users (pm-task-assignee task)))
     ((listp user-or-users)
      (--some (pm-task-is-assigned-to it task) user-or-users))
     (t (error "user-or-users must a string or list of strings"))))
#+end_src

**** Testing

***** =pm-task-is-synced=                                 :worked:tested:

This task uses its own test input, shown in Listing [[input/is-synced/1]] and [[input/is-synced/2]].

#+name: input/is-synced/1
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)

  ,* DOING A Synced Task
    :LOGBOOK:
    - State "DOING"      from "TODO"       [2022-01-06 Thu 07:27] \\
      Started
    :END:

  ,* DOING An unsynced task
#+end_src

#+name: input/is-synced/2
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)

  ,* DOING An unsynced task
#+end_src

#+name: t/is-synced
#+begin_src  emacs-lisp :noweb eval :tangle no  :wrap src text
  (pg-org-deftest pm-task/is-synced/1
      input/is-synced/1
    (-let (((task . _) (org-ml-match '(headline) doc)))
      (should (pm-task-is-synced task))))

  (pg-org-deftest pm-task/is-synced/2
      input/is-synced/2
    (-let (((task . _) (org-ml-match '(headline) doc)))
      (should (not (pm-task-is-synced task)))))

  (pg-ert-run-tests-string "pm-task/is-synced")
#+end_src

***** =pm-task-status-changed-*=                          :worked:tested:

These functions are trivial extensions of =pm-task-last-change-timestamp=, so they were a low priority to test.

They were, naturally, among the ugliest functions to debug. /Always test./

#+name: t/task-status-changed
#+begin_src emacs-lisp :noweb eval :tangle no  :wrap src text
  <<src>>


  ;; (pg-org-deftest pm-task/a-changed-on-story
  ;;     input/basic

  ;;   (let* ((truth-table '(nil t))
  ;;          (timestamp (ts-parse-org "[2021-12-11 Sat 20:36]"))
  ;;          (h1 (org-ml-match '((:and headline (:raw-value "Get past the guard")))))
  ;;          (h2 (org-ml-match '((:and headline (:raw-value "Rewire the security system")))))
  ;;          (r1 (pm-task-status-changed-on timestamp h1))
  ;;          (r2 (pm-task-status-changed-on timestamp h2)))
  ;;     (should (equal (nth 0 truth-table) r1))
  ;;     (should (equal (nth 1 truth-table) r2))))


  (pg-org-deftest pm-task/status-changed-on
      input/basic
    (cl-macrolet
        ((|-
          (fn-name org-timestamp truth-table)
          `(let* (
                  (timestamp (ts-parse-org ,org-timestamp))
                  (h1 (org-ml-match
                       '((:and headline (:raw-value "Get past the guard")))
                       doc))
                  (h2 (org-ml-match
                       '((:and headline (:raw-value "Rewire the security system")))
                       doc))
                  (r1 (,fn-name timestamp (nth 0 h1)))
                  (r2 (,fn-name timestamp (nth 0 h2))))
             ;; sensibility checks
             (should (equal (length h1) 1))
             (should (equal (length h2) 1))
             ;; tests
             (should (equal (nth 0 ,truth-table) r1))
             (should (equal (nth 1 ,truth-table) r2)))))

      ;; The chronological order of these dates, earliest to latest
      ;;
      ;;  - old
      ;;  - h2
      ;;  - h1
      ;;  - new
      ;;
      ;; (Yes, I know. But I'm repurposing a multipurpose input)

      (let ((old     "[2021-10-09 Sat 12:45]")    ;; date before all tasks
            (new     "[2022-01-09 Sun 12:45]")    ;; date after  all tasks
            (h1-date "[2021-12-31 Fri 17:48]")    ;; date of h1
            (h2-date "[2021-12-11 Sat 20:36]"))   ;; date of h2

        ;; changed-on
        (|- pm-task-status-changed-on h1-date '(t   nil))
        (|- pm-task-status-changed-on h2-date '(nil t))
        (|- pm-task-status-changed-on old     '(nil ))

        ;; changed-before
        (|- pm-task-status-changed-before new     '(t   t))
        (|- pm-task-status-changed-before old     '(nil nil))
        (|- pm-task-status-changed-before h1-date '(nil t))
        (|- pm-task-status-changed-before h2-date '(nil nil))

        ;; changed-on-or-before
        (|- pm-task-status-changed-on-or-before new     '(t   t))
        (|- pm-task-status-changed-on-or-before old     '(nil nil))
        (|- pm-task-status-changed-on-or-before h1-date '(t   t))
        (|- pm-task-status-changed-on-or-before h2-date '(nil ))

        ;; ;; changed-after
        (|- pm-task-status-changed-after new     '(nil nil))
        (|- pm-task-status-changed-after old     '(t   t))
        (|- pm-task-status-changed-after h1-date '(nil nil))
        (|- pm-task-status-changed-after h2-date '(t   nil))

        ;; ;; changed-on-or-after
        (|- pm-task-status-changed-on-or-after new     '(nil nil))
        (|- pm-task-status-changed-on-or-after old     '(t   t))
        (|- pm-task-status-changed-on-or-after h1-date '(t   nil))
        (|- pm-task-status-changed-on-or-after h2-date '(t   t)))))

  (pg-ert-run-tests-string "pm-test/status-changed-on")
#+end_src

#+RESULTS: t/task-status-changed
#+begin_src text

Ran 0 tests, 0 results as expected, 0 unexpected (2022-01-09 15:09:15-0500, 0.000067 sec)
#+end_src


***** =pm-task-status-in=                                 :worked:tested:

Input shown in Listing [[input/status-in/1]].

#+name: input/status-in/1
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)
  #
  ,* TODO to-do
  ,* DOING doing
  ,* DONE done
#+end_src

#+name: t/status-in
#+begin_src  emacs-lisp :noweb eval :tangle no  :wrap src text
  <<src/predicates>>
  (pg-org-deftest pm-task/status-in
      input/status-in/1
    (let* ((tasks (org-ml-match '(headline) doc))
           (to-do (-filter (-partial #'pm-task-status-in "TODO") tasks))
           (doing (-filter (-partial #'pm-task-status-in "DOING") tasks))
           (done (-filter (-partial #'pm-task-status-in "DONE") tasks))
           (to-do+doing (-filter
                         (-partial #'pm-task-status-in '("TODO" "DOING"))
                         tasks)))
      ;; to-do
      (should (= 1 (length to-do)))
      (should (string-equal
               "to-do" (->> (car to-do)
                            (org-ml-get-property :raw-value)
                            (org-ml-to-trimmed-string))))
      ;; doing
      (should (= 1 (length doing)))
      (should (string-equal
               "doing" (->> (car doing)
                            (org-ml-get-property :raw-value)
                            (org-ml-to-trimmed-string))))
      ;; done
      (should (= 1 (length done)))
      (should (string-equal
               "done" (->> (car done)
                           (org-ml-get-property :raw-value)
                           (org-ml-to-trimmed-string))))

      ;; to-do and doing
      (should (= 2 (length to-do+doing)))
      (should (equal (-concat to-do doing) to-do+doing))
  ))


  (pg-ert-run-tests-string "pm-task/status-in")
#+end_src

***** =pm-task-is-assigned-to=                            :worked:tested:

Input shown in Listing [[input/is-assigned-to]].

#+name: input/is-assigned-to
#+begin_src org

  ,* TODO Thing 1
    :PROPERTIES:
    :ASSIGNEE: Manny Ramirez
    :END:

  ,* TODO Thing 2
    :PROPERTIES:
    :ASSIGNEE: Moe Howard
    :END:


  ,* TODO Thing 3
    :PROPERTIES:
    :ASSIGNEE: Jack Lalanne
    :END:

  ,* TODO Thing 4


  ,* TODO Thing 5
    :PROPERTIES:
    :ASSIGNEE: Jack Lalanne
    :END:
#+end_src

#+name: t/is-assigned-to
#+begin_src  emacs-lisp :noweb eval :tangle no  :wrap src text
  <<src>>

  (pg-org-deftest pm-task/is-assigned-to
      input/is-assigned-to

    (let* ((tasks (org-ml-match '(headline) doc))
           (manny (-filter (-partial
                            #'pm-task-is-assigned-to "Manny Ramirez")
                           tasks))
           (moe   (-filter (-partial
                            #'pm-task-is-assigned-to "Moe Howard")
                           tasks))
           (jack  (-filter (-partial
                            #'pm-task-is-assigned-to "Jack Lalanne")
                           tasks))
           (manny+moe (-filter (-partial
                                #'pm-task-is-assigned-to
                                '("Manny Ramirez" "Moe Howard"))
                               tasks)))

      (should (= 1 (length manny)))
      (should (string-equal
               "Thing 1" (->> (car manny)
                              (org-ml-get-property :raw-value)
                              (org-ml-to-trimmed-string))))

      (should (= 1 (length moe)))
      (should (string-equal
               "Thing 1" (->> (car manny)
                              (org-ml-get-property :raw-value)
                              (org-ml-to-trimmed-string))))

      (should (= 2 (length jack)))
      (should (equal '("Thing 3" "Thing 5")
                     (--map (->> (org-ml-get-property :raw-value it)
                                 (org-ml-to-trimmed-string))
                            jack)))

      (should (= 2 (length manny+moe)))
      (should (equal (-concat manny moe) manny+moe))))


  (pg-ert-run-tests-string "pm-task/is-assigned-to")
#+end_src

*** Use Cases
:PROPERTIES:
:CUSTOM_ID: sct-use-cases
:END:

Let's work through some use cases and see what we need to make them happen. The Org file in Listing [[input/basic]] is the input to most of these examples.


**** Synced and unsynced tasks                             :worked:tested:

A task is said to be "synced" when its to-do item is identical to the "to" state of the most recent logbook entry. This is not a guarantee that the task is a complete record of all changes to the task, but the lack indicates that something is missing, and possibly that the task was not intended for processing by this package.

The code in listings [[ex/unsynced-tasks/1]] and [[ex/unsynced-tasks/2]] selects only unsynchronized tasks. This would most likely be used to find tasks that should be synced but aren't, or to distinguish tasks for different kinds of processing.

One consideration is what to do with tasks that are in an initial state. Currently, nothing is done, but the right answer is probably to look for a =CREATED= property and assume the task is synced if it that is present.

We use Listing [[input/unsynced-tasks]] to test this, as [[input/basic]] lacks unsynced tasks.

#+name: input/unsynced-tasks
#+caption: Sample used for testing
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :CREATED:  [2021-12-01 Wed 10:00]
    :CREATOR: Vince Lombardi
    :END:
    :LOGBOOK:
    - State "DOING"      from "BLOCKED"    [2021-12-11 Sat 20:36] \\
      Back on the case
    - State "BLOCKED"    from "DOING"      [2021-12-11 Sat 20:25] \\
      Waiting on parts from the supplier
    - State "DOING"      from "TODO"       [2021-12-11 Sat 20:14] \\
      In process, it's harder than it looks
    :END:

  ,* DONE Get past the guard
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2021-12-31 Fri 17:48] \\
      Got past 'em, easy peasy
    :END:

  ,* TODO Hey how'd this get here?


#+end_src


#+name: ex/unsynced-tasks/1
#+begin_src emacs-lisp :noweb yes :wrap src emacs-lisp :results code :tangle no
  <<src>>

  (pg-org-with-src-doc input/unsynced-tasks
    (->> doc
         (pg-org-match '((:and headline
                               (:-pred (pm-task-is-synced el)))))
         (-map (-partial #'org-ml-get-property :raw-value))))
#+end_src

#+name: ex/unsynced-tasks/2
#+begin_src emacs-lisp :noweb yes :wrap src emacs-lisp :results code :tangle no
  <<src>>

  (pg-org-with-src-doc input/unsynced-tasks
    (->> doc
         (pg-org-match '((:and headline
                               (:-pred (not (pm-task-is-synced el))))))
         (-map (-partial #'org-ml-get-property :raw-value))))
#+end_src

Note that, in this case, nothing is gained by using =pg-org-match=; one can just as easily use =(org-ml-match '((:and headline (:pred pm-task-is-synced))))=. (Assuming use of the =->>= macro as in the example.) The =pg-org-match= function is more useful when =pm-task-is-synced= and other predicates are used concurrently. It is often beneficial to use =pm-task-is-synced= in this way, to assure a task is synced before using other predicates that only make sense when applied to synchronized tasks.


**** Tasks created since \tau

This use case requires that task creation be tracked.

**** Tasks updated since \tau                                 :worked:tested:
This will return only the headline for "Get past the guard", as the timestamp for that headline falls on the time being searched for.

#+name: ex/tasks-updated-since
#+begin_src emacs-lisp :noweb yes :wrap src emacs-lisp :results code :tangle no
  <<src>>


  (let ((timestamp (ts-parse-org "[2021-12-31 Fri 17:48]")))
    (pg-org-with-src-doc input/basic
      (->> doc
           (pg-org-match
            '((:and headline
                    (:-pred
                     (and (pm-task-is-synced el)
                          (pm-task-status-changed-on-or-after
                           timestamp el))))))
           (-map (-partial #'org-ml-get-property :raw-value)))))
#+end_src

#+RESULTS: ex/tasks-updated-since
#+begin_src emacs-lisp
("Get past the guard")
#+end_src

**** Tasks resolved since \tau                                :worked:tested:

Each project has its own set of statuses, some of which can indicate that a task has been resolved in some way. It may make sense to relate project metadata to tasks at some point; one use for that is relating a task to the valid statuses for that task.

For now, we can just use =pm-task-status-in= and supply our own set of statuses.

For demonstration purposes,  we will augment our example to include tasks with other statuses representing completion. The modified input is in Listing [[input/resolved-since]].

#+name: input/resolved-since
#+caption: Sample used for testing
#+begin_src org
  ,#+seq_todo: TODO  DOING(@) BLOCKED(@) | DONE(@) CANCELLED(@)


  ,* DOING Rewire the security system
    :PROPERTIES:
    :ASSIGNEE: Bart Starr
    :CREATED:  [2021-12-01 Wed 10:00]
    :CREATOR: Vince Lombardi
    :END:
    :LOGBOOK:
    - State "DOING"      from "BLOCKED"    [2021-12-11 Sat 20:36] \\
      Back on the case
    - State "BLOCKED"    from "DOING"      [2021-12-11 Sat 20:25] \\
      Waiting on parts from the supplier
    - State "DOING"      from "TODO"       [2021-12-11 Sat 20:14] \\
      In process, it's harder than it looks
    :END:

  ,* CANCELLED Crack the safe
    :LOGBOOK:
    - State "CANCELLED"  from "TODO"       [2021-12-10 Fri 08:00] \\
      Safe's empty! We've been rumbled!
    :END:

  ,* DONE Get past the guard
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2021-12-31 Fri 17:48] \\
      Got past 'em, easy peasy
    :END:
#+end_src


#+name: ex/tasks-resolved-since
#+begin_src emacs-lisp :noweb yes :results code :tangle no :wrap src emacs-lisp
  <<src>>

  ;; t is a timestamp of interest (e.g., 7 days ago)

  (let ((timestamp (ts-parse-org "[2021-12-13 Mon 07:00]")))
    (pg-org-with-src-doc input/resolved-since
      (->> doc
           (pg-org-match
            '((:and headline
                    (:-pred
                     (and (pm-task-is-synced el)
                          (pm-task-status-in '("DONE" "CANCELLED") el))))))
           (-map (-partial #'org-ml-get-property :raw-value)))))

#+end_src

**** Tasks assigned to \upsilon                                   :worked:tested:


#+name: ex/tasks-assigned-to
#+begin_src emacs-lisp :noweb yes :wrap src emacs-lisp :results code
  <<src>>

  (pg-org-with-src-doc input/basic
    (->> doc
         (pg-org-match
          '((:and headline (:-pred (pm-task-is-assigned-to "Bart Starr" el)))))
         (-map (-partial #'org-ml-get-property :raw-value))))
#+end_src

#+RESULTS: ex/tasks-assigned-to
#+begin_src emacs-lisp
("Rewire the security system")

**** Tasks assigned to \upsilon since \tau
This use case requires that assignment changes be fully tracked, with timestamps for task creation and reassignment.

**** Tasks reassigned since \tau

**** Tasks with status \sigma                                   :worked:tested:


#+begin_src emacs-lisp :noweb yes :wrap src emacs-lisp :results code
  (pg-org-with-src-doc input/basic
    (->> doc
         (pg-org-match
          '((:and headline (:-pred (pm-task-status-in '("DONE") el)))))
         (-map (-partial #'org-ml-get-property :raw-value))))
#+end_src

#+RESULTS:
#+begin_src emacs-lisp
("Get past the guard")
#+end_src

**** All unresolved tasks



* Provide

#+BEGIN_SRC emacs-lisp :noweb-ref src
  (provide 'pm-task)
  ;;; pm-task.el ends here
#+END_SRC
